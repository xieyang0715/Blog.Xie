---
title: 服务网格安全
date: 2021-09-21 12:34:20
tags:
- istio
---



# 微服务架构及API

南北流量

东西流量：基于tls认证， 服务是否允许被访问，

零信任的网络：mtls, rbac, certification rotation.



# 常见应对网络安全风险

network level controls.

- localhost isolation
- network segmentation
- **ssl/tls 双向认证SSL**

application level controler

- traditional web tokens
  - cookie-based session
  - saml

- api-oreignted tokens
  - api keys
  - oauth 2.0
  - openid connect
  - **jwt**: 服务端生成客户端的jwt, 将jwt直接给客户端，客户端直接带上jwt。服务端基于签名验证jwt. 客户端需要带大量的数据。可以跨域访问
- tokens types
  - opaque
  - transparent

> ingress/egress: `jwt` + `tls/mtls`
>
> 内部: `mtls`

可以南北加密，东西不加密

可以南北加密，东西加密

## envoy认证机制 

jwt 用户认证

listener filter 可以多个服务端类型的证书

upstream pool 只能单个客户端证书

1. 手工配置: 
   - listener, cluster.
   - static_resousrces 将证书定义为secret, listener, cluster中引用。
2. SDS server 配置证书。



# 静态配置 tls

安全：访问源是否安全，通信过程TLS, 终端用户是否身份认证及其访问行为是否控制或审计。

采用方式：

- 来源认证：双向TLS（也实现了通信加密）
- 终端用户认证：jwt(java web token)

envoy 网络: 每一处jwt + tls或jwt + mtls.  mtls就是双向互相认证。

网格内服务间与服务间通信：需要使用自建的CA证书验证对方的证书

ingress入口：提供给客户端，配置在listener之上。

ingress到上游服务器，验证对方的证书时，配置在cluster之上。



设定证书方式

- 静态
  - listener/cluster: 定义证书及匹配的私钥.
  - 证书定义了secret, listener/cluster中引用secret. 可以复用。
- SDS

## 证书认证示例

![image-20210921135734228](http://myapp.img.mykernel.cn/image-20210921135734228.png)

定义 secret. `static_resources.secrets`, 列表项，每一项要么是证书，要么是检验对端证书, 证书格式项检验

- user-> server 公信ca的证书
- cluster1 -> 3个主机的集群，不定义tls上下文
- cluster2->  集群，定义服务端证书，需要验证服务端证书，但是服务端不验证客户端证书。
- cluster3->集群，双向认证

成千上万的服务网格，手工管理不现实，这里只是让我们了解配置如何进行的。

为了演示方便，在`servicemesh_in_practise-master/security/tls-static`中有`gencerts.sh`

```bash
[root@ip-10-0-0-91 tls-static]# ls -l certs/CA
total 8
-rw-r--r--. 1 root root 1830 Apr 23  2020 ca.crt # 互相验证对端的证书
-rw-r--r--. 1 root root 3243 Apr 23  2020 ca.key
[root@ip-10-0-0-91 tls-static]# ls -l certs/front-envoy/
total 16
-rw-r--r--. 1 root root 1578 Apr 23  2020 client.crt # 第3个集群上的envoy到front envoy通信为客户端
-rw-r--r--. 1 root root 1679 Apr 23  2020 client.key
-rw-r--r--. 1 root root 1643 Apr 23  2020 server.crt # front envoy面向用户
-rw-r--r--. 1 root root 1679 Apr 23  2020 server.key
[root@ip-10-0-0-91 tls-static]# ls -l certs/service-gray/ # 第2个集群的后端为服务端的证书
total 8
-rw-r--r--. 1 root root 1643 Apr 23  2020 server.crt
-rw-r--r--. 1 root root 1679 Apr 23  2020 server.key
[root@ip-10-0-0-91 tls-static]# ls -l certs/service-purple/ # 第3个集群的后端为服务端的证书
total 8
-rw-r--r--. 1 root root 1647 Apr 23  2020 server.crt
-rw-r--r--. 1 root root 1679 Apr 23  2020 server.key
```



```bash
[root@ip-10-0-0-91 tls-static]# ls -l
total 28
drwxr-xr-x. 6 root root   77 Apr 23  2020 certs
-rw-r--r--. 1 root root 1913 Apr 23  2020 docker-compose.yaml
-rw-r--r--. 1 root root 3953 Apr 23  2020 front-envoy.yaml
-rwxr-xr-x. 1 root root 2830 Apr 23  2020 gencerts.sh
-rw-r--r--. 1 root root 3225 Apr 23  2020 openssl.conf
-rw-r--r--. 1 root root  158 Apr 23  2020 README.md
-rw-r--r--. 1 root root 2236 Apr 23  2020 service-gray.yaml
-rw-r--r--. 1 root root 2378 Apr 23  2020 service-purple.yaml
```

> `docker-compose.yaml` gray是第2个集群，只需要自己的证书，原因是 客户端验证它，所以不需要验证客户端。
>
> purple, 有自己的证书和CA的证书，他拿着CA的证书，是 为了检验与其他主机通信时对端的证书。
>
> `front-envoy.yaml` 
>
> ```yaml
> 
> static_resources:
>   secrets:
>   - name: server_cert
>     tls_certificate:
>       certificate_chain:
>         filename: "/etc/envoy/certs/server.crt"
>       private_key:
>         filename: "/etc/envoy/certs/server.key"
>   - name: client_cert
>     tls_certificate:
>       certificate_chain:
>         filename: "/etc/envoy/certs/client.crt"
>       private_key:
>         filename: "/etc/envoy/certs/client.key"
>   - name: validation_context
>     validation_context:
>       trusted_ca:
>         filename: "/etc/envoy/ca/ca.crt"
> ```
>
> ```yaml
> listeners:
>   - name: listener_https
>     address:
>       socket_address: { address: 0.0.0.0, port_value: 443 }
>     filter_chains:
>     - filters:
>       - name: envoy.http_connection_manager
>         typed_config:
>           "@type": type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager
>           stat_prefix: ingress_https
>           codec_type: AUTO
>           route_config:
>             name: https_route
>             virtual_hosts:
>             - name: https_route
>               domains: ["*"]
>               routes:
>               - match:
>                   prefix: "/service/gray"
>                 route:
>                   cluster: service-gray
>               - match:
>                   prefix: "/service/purple"
>                 route:
>                   cluster: service-purple
>               - match:
>                   prefix: "/"
>                 route:
>                   cluster: mycluster
>           http_filters:
>           - name: envoy.router
>             typed_config: {}
>       tls_context:
>         common_tls_context:
>           tls_certificate_sds_secret_configs:
>           - name: server_cert
> ```
>
> > server_cert 表示既不要求客户端证书，也不验证客户端证书。
>
> ```yaml
>   clusters:
>   - name: service-gray
>     connect_timeout: 0.25s
>     type: STRICT_DNS
>     lb_policy: ROUND_ROBIN
>     http2_protocol_options: {}
>     load_assignment:
>       cluster_name: service-gray
>       endpoints:
>       - lb_endpoints:
>         - endpoint:
>             address:
>               socket_address:
>                 address: service-gray
>                 port_value: 443
>     tls_context:
>       common_tls_context:
>         validation_context_sds_secret_config:
>           name: validation_context
> ```
>
> > 在upstream中引用了 validation_context, 表示验证对端的证书，不给对端提供证书
>
> ```yaml
>   clusters:
>   - name: service-purple
>     connect_timeout: 0.25s
>     type: STRICT_DNS
>     lb_policy: ROUND_ROBIN
>     http2_protocol_options: {}
>     load_assignment:
>       cluster_name: service-purple
>       endpoints:
>       - lb_endpoints:
>         - endpoint:
>             address:
>               socket_address:
>                 address: service-purple
>                 port_value: 443
>     tls_context:
>       common_tls_context:
>         tls_certificate_sds_secret_configs:
>         - name: client_cert
>         validation_context_sds_secret_config:
>           name: validation_context
> ```
>
> > - 提供给对方证书
> >
> > - 又要验证对方证书
>
> `service-gray.yaml`
>
> ```yaml
> static_resources:
>   listeners:
>   - name: listener_https
>     address:
>       socket_address: { address: 0.0.0.0, port_value: 443 }
>     filter_chains:
>     - filters:
>       - name: envoy.http_connection_manager
>         typed_config:
>           "@type": type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager
>           stat_prefix: ingress_https
>           codec_type: AUTO
>           route_config:
>             name: https_route
>             virtual_hosts:
>             - name: https_route
>               domains: ["*"]
>               routes:
>               - match:
>                   prefix: "/"
>                 route:
>                   cluster: local_service
>           http_filters:
>           - name: envoy.router
>             typed_config: {}
>       tls_context:
>         common_tls_context:
>           tls_certificates:
>           - certificate_chain:
>               filename: "/etc/envoy/certs/server.crt"
>             private_key:
>               filename: "/etc/envoy/certs/server.key"
> 
> ```
>
> > filter上提供自己的服务端证书即可，没有通过secret 定义
>
> `service-purple.yaml`
>
> ```yaml
> static_resources:
>   listeners:
>   - name: listener_https
>     address:
>       socket_address: { address: 0.0.0.0, port_value: 443 }
>     filter_chains:
>     - filters:
>       - name: envoy.http_connection_manager
>         typed_config:
>           "@type": type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager
>           stat_prefix: ingress_https
>           codec_type: AUTO
>           route_config:
>             name: https_route
>             virtual_hosts:
>             - name: https_route
>               domains: ["*"]
>               routes:
>               - match:
>                   prefix: "/"
>                 route:
>                   cluster: local_service
>           http_filters:
>           - name: envoy.router
>             typed_config: {}
>       tls_context:
>         common_tls_context:
>           tls_certificates:
>           - certificate_chain:
>               filename: "/etc/envoy/certs/server.crt"
>             private_key:
>               filename: "/etc/envoy/certs/server.key"
>           validation_context:
>             trusted_ca:
>               filename: "/etc/envoy/ca/ca.crt"
>         require_client_certificate: true
> 
> ```
>
> > 需要验证对方，也需要自己提供服务端证书

启动

```bash
docker-compose up
```

集群状态

```bash
[root@ip-10-0-0-91 security]# docker exec tls-static_front-envoy_1 ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:C0:A8:C0:03  
          inet addr:192.168.192.3  Bcast:192.168.207.255  Mask:255.255.240.0
```

```bash
[root@ip-10-0-0-91 security]# curl -s 192.168.192.3:9901/clusters  | grep flag
mycluster::192.168.192.2:80::health_flags::healthy
mycluster::192.168.192.6:80::health_flags::healthy
mycluster::192.168.192.4:80::health_flags::healthy
service-purple::192.168.192.7:443::health_flags::healthy
service-gray::192.168.192.5:443::health_flags::healthy
```

> mycluster是明文
>
> gray, purple是443通信.

```bash
[root@ip-10-0-0-91 security]# curl  localhost:8443/service/colored
curl: (52) Empty reply from server
```

测试访问

```bash
[root@ip-10-0-0-91 security]# curl  https://localhost:8443/service/colored # 需要验证对方证书，可以指定CA证书
curl: (60) Peer's Certificate issuer is not recognized.
More details here: http://curl.haxx.se/docs/sslcerts.html

curl performs SSL certificate verification by default, using a "bundle"
 of Certificate Authority (CA) public keys (CA certs). If the default
 bundle file isn't adequate, you can specify an alternate file
 using the --cacert option.
If this HTTPS server uses a certificate signed by a CA represented in
 the bundle, the certificate verification probably failed due to a
 problem with the certificate (it might be expired, or the name might
 not match the domain name in the URL).
If you'd like to turn off curl's verification of the certificate, use
 the -k (or --insecure) option.
[root@ip-10-0-0-91 security]# curl -k  https://localhost:8443/service/colored
<body bgcolor="red"><span style="color:white;font-size:4em;">
Hello from red (hostname: 3b6819beef76 resolvedhostname:192.168.192.5)
</span></body>
```

测试front -> gray, 单向tls

```bash
[root@ip-10-0-0-91 tls-static]# curl -k  https://localhost:8443/service/gray
<body bgcolor="gray"><span style="color:white;font-size:4em;">
Hello from gray (hostname: 21063a1208d3 resolvedhostname:192.168.192.3)
</span></body>
```

测试front <-> purple , 双向tls

```bash
[root@ip-10-0-0-91 tls-static]# curl -k  https://localhost:8443/service/purple
<body bgcolor="purple"><span style="color:white;font-size:4em;">
Hello from purple (hostname: b1d6f016ce13 resolvedhostname:192.168.192.7)
</span></body>
```

>  wireshark分析https通信过程

查看证书

```yaml
[root@ip-10-0-0-91 tls-static]# curl -s 192.168.192.2:9901/certs | yq -y
certificates:
  - ca_cert:
      - path: /etc/envoy/ca/ca.crt
        serial_number: 0b542c4e26db0a046e0c2f3e393ee528ccd18872
        subject_alt_names: []
        days_until_expiration: '2970'
        valid_from: '2019-11-12T04:10:06Z'
        expiration_time: '2029-11-09T04:10:06Z'
    cert_chain: []
  - ca_cert:
      - path: /etc/envoy/ca/ca.crt
        serial_number: 0b542c4e26db0a046e0c2f3e393ee528ccd18872
        subject_alt_names: []
        days_until_expiration: '2970'
        valid_from: '2019-11-12T04:10:06Z'
        expiration_time: '2029-11-09T04:10:06Z'
    cert_chain:
      - path: /etc/envoy/certs/client.crt
        serial_number: '1001'
        subject_alt_names: []
        days_until_expiration: '2970'
        valid_from: '2019-11-12T04:10:24Z'
        expiration_time: '2029-11-09T04:10:24Z'
  - ca_cert: []
    cert_chain:
      - path: /etc/envoy/certs/server.crt
        serial_number: '1000'
        subject_alt_names: []
        days_until_expiration: '2970'
        valid_from: '2019-11-12T04:10:15Z'
        expiration_time: '2029-11-09T04:10:15Z'
```



# SDS证书

借助spire实现spiffe, 从spire获取证书、私钥，而且可以轮替，并且可以实现认证和权限。

spiffe跨异构环境向服务发布身份ID的规模框架。

1. 注册：将身份信息发给spire, spire通过底层平台验证其身份。

   spire拿着身份信息做成SVID，发给请求者。X509格式就是证书。

2. spire server, 可以定期更换所有 签发的证书

3. 现在多个工作负载之间就可以基于mtls通信了。

spiffe组件

- `spiffe id`   `spiffe://trust domain/workload identifier`.
- `trust domain` 可信域，自注册，必须有签名机构，此机构也必须有SVID。
- `SVID` 证明自身的文档，CA签署才有效。X509-SVID和JWT-SVID，后1种格式容易受到重放攻击。
- `workload api` 颁发`x509-svid`或`jwt-svid`.

​            

spiffe 发svid给agent

1. agent注册身份到apire server
2. server 通过底层系统检验节点
3. 生成svid发给agent
4. agent拿着svid与spire server通信。

agent发svid给workload

1. WL注册到agent
2. agent通过kernel/k8s认证pod/docker认证容器
3. 获取workload信息，提交给sever, server签发svid
4. agent把svid给workload

spire agent与spire server

1. 生成密钥对
2. 证明身份
3. 生成证书签发请求，发给server
4. server证明身份
5. 发spiffe id

## 架构

![image-20210921151255166](http://myapp.img.mykernel.cn/image-20210921151255166.png)

## 启动项目

```bash
ls -l servicemesh_in_practise-master/security/tls-spire
drwxr-xr-x. 2 root root   27 Apr 23  2020 bootstrap
drwxr-xr-x. 6 root root   77 Apr 23  2020 certs
-rwxr-xr-x. 1 root root 2492 Apr 23  2020 configure-spire.sh
-rw-r--r--. 1 root root 2551 Apr 23  2020 docker-compose.yaml
drwxr-xr-x. 2 root root  136 Apr 23  2020 front-envoy
-rwxr-xr-x. 1 root root 3219 Apr 23  2020 gencerts.sh
-rw-r--r--. 1 root root 3520 Apr 23  2020 openssl.conf
-rw-r--r--. 1 root root  433 Apr 23  2020 README.md
drwxr-xr-x. 2 root root  100 Apr 23  2020 service-gray
drwxr-xr-x. 2 root root  100 Apr 23  2020 service-purple
drwxr-xr-x. 2 root root   45 Apr 23  2020 spire-server
-rwxr-xr-x. 1 root root  183 Apr 23  2020 start-spire-agent.sh
```

> `docker-compose.yaml` 
>
> `service-gray/spire-agent.conf`
>
> ```bash
> agent {
> 	data_dir = "/opt/spire/data/agent"
> 	log_level = "DEBUG"
> 	log_file = "/dev/stdout"
> 	plugin_dir = "/opt/spire/conf/agent/plugin"
> 	server_address = "spire-server"
> 	server_port = "9081"
> 	socket_path ="/tmp/agent.sock"
> 	trust_bundle_path = "/opt/spire/conf/agent/bootstrap.crt" # server启动后，拿到证书才能启用agent；为了简便此文件通过挂载生成
> 	trust_domain = "ilinux.io" # 可信域
> 	enable_sds = true
> }
> ```
>
> `spire-server/spire-server.conf`
>
> ```bash
> server {
> 	bind_address = "0.0.0.0"
> 	bind_port = "9081"
> 	registration_uds_path = "/tmp/spire-registration.sock"
> 	trust_domain = "ilinux.io" # 可信域
> 	data_dir = "/opt/spire/data/server"
> 	plugin_dir = "/opt/spire/conf/server/plugin"
> 	log_level = "DEBUG"
> 	log_file = "/dev/stdout"
> 	upstream_bundle = false
> 	svid_ttl = "1h"
> 	ca_subject = { # 自己的ca
> 		Country = ["CN"], # 国家
> 		Organization = ["SPIFFE"], # 组织
> 		CommonName = "",
> 	}
> }
> 
> plugins { # 插件
> 	DataStore "sql" {
> 		plugin_data {
> 			database_type = "sqlite3"
> 				connection_string = "/opt/spire/data/server/datastore.sqlite3"
> 		}
> 	}
> 	NodeAttestor "x509pop" {
> 		plugin_data {
> 			ca_bundle_path = "/opt/spire/conf/server/agent-cacert.pem"
> 		}
> 	}
> 
> 	NodeResolver "noop" {
> 		plugin_data {}
> 	}
> 
> 	KeyManager "disk" {
> 		plugin_data = {
> 			keys_path = "/opt/spire/data/server/keys.json"
> 		}
> 	}
> }
> ```
>
> ca证书
>
> ```bash
> root@ip-10-0-0-245:~/servicemesh_in_practise-master/security/tls-spire# ls spire-server/
> ca.crt  spire-server.conf
> ```
>
> agent证书
>
> ```bash
> root@ip-10-0-0-245:~/servicemesh_in_practise-master/security/tls-spire# ls service-gray/
> Dockerfile        agent.crt         agent.key         envoy.yaml        spire-agent.conf  
> ```
>
> 引导证书, spire-server和envoy的agent均需要加载此证书
>
> ```bash
> root@ip-10-0-0-245:~/servicemesh_in_practise-master/security/tls-spire# ls bootstrap/
> bootstrap.crt
> ```
>
> 前端的envoy的证书 `cat front-envoy/envoy.yaml`
>
> ```yaml
> static_resources: # 由于是面向客户端，只提供证书，所以静态配置
>   secrets:
>   - name: server_cert
>     tls_certificate:
>       certificate_chain:
>         filename: "/etc/envoy/certs/server.crt"
>       private_key:
>         filename: "/etc/envoy/certs/server.key"
> 
>   listeners:
>   - name: listener_http
> 
> ```
>
> ```yaml
>   clusters:
>   - name: spire_agent
>     connect_timeout: 0.25s
>     http2_protocol_options: {}
>     hosts:
>       - pipe:
>           path: /tmp/agent.sock
> 
>   - name: service-gray
>     connect_timeout: 0.25s
>     type: strict_dns
>     lb_policy: ROUND_ROBIN
>     hosts:
>       - socket_address:
>           address: service-gray
>           port_value: 443
>     tls_context: # 面向后端集群配置证书
>       common_tls_context:
>         tls_certificate_sds_secret_configs:
>           - name: "spiffe://ilinux.io/front-envoy" # ID
>             sds_config:
>               api_config_source:
>                 api_type: GRPC
>                 grpc_services:
>                   envoy_grpc:
>                     cluster_name: spire_agent # ID签署请求发给spire_agent集群, agent再请求server, server签发给agent, agent把证书给envoy.
>         combined_validation_context: # 组合格式
>           # validate the SPIFFE ID of the server
>           default_validation_context: # 对端证书有备用名称 
>             verify_subject_alt_name: 
>               - "spiffe://ilinux.io/service-gray"
>           validation_context_sds_secret_config:
>             name: "spiffe://ilinux.io" # 信任的CA的格式
>             sds_config:
>               api_config_source:
>                 api_type: GRPC
>                 grpc_services:
>                   envoy_grpc:
>                     cluster_name: spire_agent
> ```
>
> 后端服务的`cat service-gray/envoy.yaml `
>
> ```diff
> 
> static_resources:
>   listeners:
>   - name: listener_http
>     address:
>       socket_address:
>         address: 0.0.0.0
>         port_value: 80
>     filter_chains:
>     - filters:
>       - name: envoy.http_connection_manager
>         typed_config:
>           "@type": type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager
>           codec_type: auto
>           stat_prefix: ingress_http
>           route_config:
>             name: local_route
>             virtual_hosts:
>             - name: service
>               domains:
>               - "*"
>               routes:
>               - match:
>                   prefix: "/"
>                 route:
>                   cluster: local_service
>           http_filters:
>           - name: envoy.router
>             typed_config: {}
> 
>   - name: listener_https
>     address:
>       socket_address: { address: 0.0.0.0, port_value: 443 }
>     filter_chains:
>     - filters:
>       - name: envoy.http_connection_manager
>         typed_config:
>           "@type": type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager
>           stat_prefix: ingress_https
>           codec_type: AUTO
>           route_config:
>             name: https_route
>             virtual_hosts:
>             - name: https_route
>               domains: ["*"]
>               routes:
>               - match:
>                   prefix: "/"
>                 route:
>                   cluster: local_service
>           http_filters:
>           - name: envoy.router
>             typed_config: {}
> +      tls_context: # listener 直接走的是SDS, 没有静态，通过轮替方式。 
>         common_tls_context:
>           tls_certificate_sds_secret_configs:
>           - name: "spiffe://ilinux.io/service-gray"
>             sds_config:
>               api_config_source:
>                 api_type: GRPC
>                 grpc_services:
>                   envoy_grpc:
>                     cluster_name: spire_agent
>           # obtain the trust bundle from SDS
>           validation_context_sds_secret_config:
> +              name: "spiffe://ilinux.io" # 没有组合方式，必须CA名
>               sds_config:
>                 api_config_source:
>                   api_type: GRPC
>                   grpc_services:
>                     envoy_grpc:
>                       cluster_name: spire_agent
> ```

```bash
docker-compose up
```

>  启动后，大量的envoy+agent报错，即docker-compose展示`service-purple`  agent还没有接入到spire-server, 所以启动失败，agent不启动，所以获取证书也会失败。
>
> ```bash
> service-gray_1    | [2021-09-28 01:25:04.664][7][warning][config] [bazel-out/k8-opt/bin/source/common/config/_virtual_includes/grpc_stream_lib/common/config/grpc_stream.h:87] gRPC config stream closed: 14, upstream connect error or disconnect/reset before headers. reset reason: connection failure
> ```

现在需要执行补充步骤`configure-spire.sh` 脚本用于完成，为front-envoy, service-purple/gray分别注入对应的引导证书(spire-server自己生成的ca证书)，从而完成3个agent加入到`spire-server`, 然后让envoy注册到spire-server

```bash
docker-compose exec spire-server bin/spire-server entry create \ # 在spire-server中
        -selector unix:user:root \      # root用户
        -spiffeID spiffe://ilinux.io/front-envoy \ # 生成spiffeID
        -parentID spiffe://ilinux.io/spire/agent/x509pop/${front_envoy_fingerprint}  # 生成x509证书
        
docker-compose exec spire-server bin/spire-server entry create \
        -selector unix:user:root \
        -spiffeID spiffe://ilinux.io/service-gray \
        -parentID spiffe://ilinux.io/spire/agent/x509pop/${service_gray_fingerprint}

docker-compose exec spire-server bin/spire-server entry create \
        -selector unix:user:root \
        -spiffeID spiffe://ilinux.io/service-purple \
        -parentID spiffe://ilinux.io/spire/agent/x509pop/${service_purple_fingerprint}
```

> 将来使用istio citadel这个都不需要的

运行脚本

```bash
root@ip-10-0-0-245:~/servicemesh_in_practise-master/security/tls-spire# ./configure-spire.sh 
Bootstrapping trust between SPIRE agents and SPIRE server...
Starting front-envoy SPIRE agent...
Starting service-gray SPIRE agent...
Starting service-purple SPIRE agent...

Creating registration entry for the front-envoy ...
Entry ID      : 8727e602-91d3-463b-8bbb-8d29a9c15372
SPIFFE ID     : spiffe://ilinux.io/front-envoy
Parent ID     : spiffe://ilinux.io/spire/agent/x509pop/116830be010af61cb0e69fd9af094c86906c9a47
TTL           : 3600
Selector      : unix:user:root

Creating registration entry for the service-gray ...
Entry ID      : e23edff4-dfbd-4de3-bd22-450cfca40e71
SPIFFE ID     : spiffe://ilinux.io/service-gray
Parent ID     : spiffe://ilinux.io/spire/agent/x509pop/4fb22b62e70b114b9b91569ce7a25d389855d28a
TTL           : 3600
Selector      : unix:user:root

Creating registration entry for the service-purple ...
Entry ID      : 03efaf6b-4499-46cc-8781-e40ce0273517
SPIFFE ID     : spiffe://ilinux.io/service-purple
Parent ID     : spiffe://ilinux.io/spire/agent/x509pop/2a188a2121fb7be23d67e1c523137b86a4aa17e1
TTL           : 3600
Selector      : unix:user:root
```

现在查看docker-compose控制台，报错不出现了，意味着3个节点运行正常了

```bash
spire-server_1    | DEBU[0213] Signing CSR for Agent SVID                    agent_id="spiffe://ilinux.io/spire/agent/x509pop/116830be010af61cb0e69fd9af094c86906c9a47" attestor=x509pop method=node_api spiffe_id="spiffe://ilinux.io/spire/agent/x509pop/116830be010af61cb0e69fd9af094c86906c9a47" subsystem_name=node_api
spire-server_1    | DEBU[0213] Signed X509 SVID                              expiration="2021-09-28T02:28:35Z" spiffe_id="spiffe://ilinux.io/spire/agent/x509pop/116830be010af61cb0e69fd9af094c86906c9a47" subsystem_name=ca
spire-server_1    | DEBU[0213] could not find node resolver                  attestor=x509pop subsystem_name=node_api
spire-server_1    | INFO[0213] Node attestation request completed            address="172.19.0.3:50998" attestor=x509pop method=node_api spiffe_id="spiffe://ilinux.io/spire/agent/x509pop/116830be010af61cb0e69fd9af094c86906c9a47" subsystem_name=node_api
spire-server_1    | DEBU[0214] Signing CSR for Agent SVID                    agent_id="spiffe://ilinux.io/spire/agent/x509pop/4fb22b62e70b114b9b91569ce7a25d389855d28a" attestor=x509pop method=node_api spiffe_id="spiffe://ilinux.io/spire/agent/x509pop/4fb22b62e70b114b9b91569ce7a25d389855d28a" subsystem_name=node_api
spire-server_1    | DEBU[0214] Signed X509 SVID                              expiration="2021-09-28T02:28:36Z" spiffe_id="spiffe://ilinux.io/spire/agent/x509pop/4fb22b62e70b114b9b91569ce7a25d389855d28a" subsystem_name=ca
spire-server_1    | DEBU[0214] could not find node resolver                  attestor=x509pop subsystem_name=node_api
spire-server_1    | INFO[0214] Node attestation request completed            address="172.19.0.7:44796" attestor=x509pop method=node_api spiffe_id="spiffe://ilinux.io/spire/agent/x509pop/4fb22b62e70b114b9b91569ce7a25d389855d28a" subsystem_name=node_api
spire-server_1    | DEBU[0214] Signing CSR for Agent SVID                    agent_id="spiffe://ilinux.io/spire/agent/x509pop/2a188a2121fb7be23d67e1c523137b86a4aa17e1" attestor=x509pop method=node_api spiffe_id="spiffe://ilinux.io/spire/agent/x509pop/2a188a2121fb7be23d67e1c523137b86a4aa17e1" subsystem_name=node_api
spire-server_1    | DEBU[0214] Signed X509 SVID                              expiration="2021-09-28T02:28:36Z" spiffe_id="spiffe://ilinux.io/spire/agent/x509pop/2a188a2121fb7be23d67e1c523137b86a4aa17e1" subsystem_name=ca
spire-server_1    | DEBU[0214] could not find node resolver                  attestor=x509pop subsystem_name=node_api
spire-server_1    | INFO[0214] Node attestation request completed            address="172.19.0.6:34436" attestor=x509pop method=node_api spiffe_id="spiffe://ilinux.io/spire/agent/x509pop/2a188a2121fb7be23d67e1c523137b86a4aa17e1" subsystem_name=node_api
spire-server_1    | DEBU[0218] Signing SVID                                  address="172.19.0.3:51000" caller_id="spiffe://ilinux.io/spire/agent/x509pop/116830be010af61cb0e69fd9af094c86906c9a47" spiffe_id="spiffe://ilinux.io/front-envoy" subsystem_name=node_api
spire-server_1    | DEBU[0218] Signed X509 SVID                              expiration="2021-09-28T02:28:40Z" spiffe_id="spiffe://ilinux.io/front-envoy" subsystem_name=ca
spire-server_1    | DEBU[0219] Signing SVID                                  address="172.19.0.7:44800" caller_id="spiffe://ilinux.io/spire/agent/x509pop/4fb22b62e70b114b9b91569ce7a25d389855d28a" spiffe_id="spiffe://ilinux.io/service-gray" subsystem_name=node_api
spire-server_1    | DEBU[0219] Signed X509 SVID                              expiration="2021-09-28T02:28:41Z" spiffe_id="spiffe://ilinux.io/service-gray" subsystem_name=ca
spire-server_1    | DEBU[0219] Signing SVID                                  address="172.19.0.6:34438" caller_id="spiffe://ilinux.io/spire/agent/x509pop/2a188a2121fb7be23d67e1c523137b86a4aa17e1" spiffe_id="spiffe://ilinux.io/service-purple" subsystem_name=node_api
spire-server_1    | DEBU[0219] Signed X509 SVID                              expiration="2021-09-28T02:28:41Z" spiffe_id="spiffe://ilinux.io/service-purple" subsystem_name=ca
```

验证agent是否启动

```bash
root@ip-10-0-0-245:~/servicemesh_in_practise-master/security/tls-spire# docker-compose exec front-envoy ps -ef
PID   USER     TIME  COMMAND
    1 root      0:00 envoy -c /etc/envoy/envoy.yaml
   19 root      0:00 bin/spire-agent run # 这个agent已经run了
   37 root      0:00 ps -ef
```

```bash
root@ip-10-0-0-245:~/servicemesh_in_practise-master/security/tls-spire# docker-compose ps
           Name                         Command               State                                       Ports                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
tls-spire_blue_1             /bin/sh -c /usr/local/bin/ ...   Up      10000/tcp, 80/tcp                                                             
tls-spire_front-envoy_1      /docker-entrypoint.sh envo ...   Up      10000/tcp, 0.0.0.0:8443->443/tcp, 0.0.0.0:8080->80/tcp, 0.0.0.0:9901->9901/tcp
tls-spire_green_1            /bin/sh -c /usr/local/bin/ ...   Up      10000/tcp, 80/tcp                                                             
tls-spire_red_1              /bin/sh -c /usr/local/bin/ ...   Up      10000/tcp, 80/tcp                                                             
tls-spire_service-gray_1     /bin/sh -c /usr/local/bin/ ...   Up      10000/tcp, 443/tcp, 80/tcp                                                    
tls-spire_service-purple_1   /bin/sh -c /usr/local/bin/ ...   Up      10000/tcp, 443/tcp, 80/tcp                                                    
tls-spire_spire-server_1     /usr/bin/dumb-init /opt/sp ...   Up           
```

现在访问`admin`接口

```bash
root@ip-10-0-0-245:~/servicemesh_in_practise-master/security/tls-spire# curl -s 0:9901/certs  | yq -y .
certificates:
  - ca_cert: []
    cert_chain: 
      - path: /etc/envoy/certs/server.crt # 自建
        serial_number: '1000'
        subject_alt_names: []
        days_until_expiration: '2964'
        valid_from: '2019-11-12T06:23:15Z'
        expiration_time: '2029-11-09T06:23:15Z'
  - ca_cert: # spire-server生成的证书，有效期1个小时，说明证书也自动轮替了
      - path: <inline>
        serial_number: '0'
        subject_alt_names:
          - uri: spiffe://ilinux.io
        days_until_expiration: '0'
        valid_from: '2021-09-28T01:24:51Z' 
        expiration_time: '2021-09-29T01:25:01Z'
    cert_chain:
      - path: <inline>
        serial_number: 363863368a4f31480268796178f70903
        subject_alt_names:
          - uri: spiffe://ilinux.io/front-envoy
        days_until_expiration: '0'
        valid_from: '2021-09-28T01:28:30Z' # 1个小时过期
        expiration_time: '2021-09-28T02:28:40Z'
  - ca_cert:
      - path: <inline>
        serial_number: '0'
        subject_alt_names:
          - uri: spiffe://ilinux.io
        days_until_expiration: '0'
        valid_from: '2021-09-28T01:24:51Z'
        expiration_time: '2021-09-29T01:25:01Z'
    cert_chain:
      - path: <inline>
        serial_number: 363863368a4f31480268796178f70903
        subject_alt_names:
          - uri: spiffe://ilinux.io/front-envoy
        days_until_expiration: '0'
        valid_from: '2021-09-28T01:28:30Z'
        expiration_time: '2021-09-28T02:28:40Z'
```

查看cluster

```bash
root@ip-10-0-0-245:~/servicemesh_in_practise-master/security/tls-spire# curl -s 0:9901/clusters | grep flag
spire_agent::/tmp/agent.sock::health_flags::healthy
mycluster::172.19.0.4:80::health_flags::healthy
mycluster::172.19.0.8:80::health_flags::healthy
mycluster::172.19.0.2:80::health_flags::healthy
service-purple::172.19.0.6:443::health_flags::healthy
service-gray::172.19.0.7:443::health_flags::healthy
```

> 后面的服务均走443端口
>
> 其余的明文走的80

现在访问`8443` 走的tls, 到明文正常

```bash
root@ip-10-0-0-245:~/servicemesh_in_practise-master/security/tls-spire# curl -k https://0:8443/service/colored
<body bgcolor="red"><span style="color:white;font-size:4em;">
Hello from red (hostname: 62d0635e1530 resolvedhostname:172.19.0.4)
</span></body>
```

访问gray

```bash
root@ip-10-0-0-245:~/servicemesh_in_practise-master/security/tls-spire# curl -k https://0:8443/service/gray
<body bgcolor="gray"><span style="color:white;font-size:4em;">
Hello from gray (hostname: service-gray resolvedhostname:172.19.0.7)
</span></body>


service-gray_1    | 127.0.0.1 - - [28/Sep/2021 01:36:59] "GET /service/gray HTTP/1.1" 200 -
```

> 的确是gray响应，后端 tls也正常

<div class="admonition note">
	<p class="admonition-title">note</p>
	<span>将来使用envoy,</span>
    <span><b>citadel底层逻辑MTLS</b>就这样，</span>
    <span>而且还不需要关心证书怎么生成。</span>
    <p>
        将来对底层排查时，就使用类似的方式进行
    </p>
    <p>
        如果有条件的同学，可以使用wireshark分析TLS Handshark过程
    </p>
    <p>
        还有一个实例，叫spire-example, 工作逻辑与当前tls相像，就没有测试了 &gt;&gt;
    </p>
</div>



# JWT和RBAC和ABAC

最终用户**认证**：jwt

服务网格**授权**：rbac

基于策略**授权**:abac

## JWT认证

spire认证，请求来源认证

JWT认证，希望来自同一个服务的不同用户赋于不同的访问权限，应该在被访问服务构建最终用户概念，客户端需要带最终用户的认证行为，不同用户就有了不同的权限。

web认证:

-  传统`cookie` `session` `saml` 
- api `jwt` `oauth` `openid`



jwt: `json web token`，逻辑类似cookie, session.



## jwt 认证流程

1. 认证登陆请求
2. 服务端，`payload`,`sign options`, `private.key` jwt代码基于这些生成令牌，签名令牌，就生成`jwt token.` 把token给客户端
3. 客户端拿到令牌后，存储在localstorage.
4. 随后客户端访问服务器，会携带jwt令牌令牌，在 authorization标头，使用bare来承载令牌
5. 服务端，使用public.key验证jwt 签名，验证payload, 验证完成。基于用户的身份，获取用户的内容，将响应内容发给用户。

> 检验来源合法：RSA
>
> 检验内容未被篡改：payload 对称加密 



### jwt组成

header.payload.signature

- header: 格式、加密算法
- payload：令牌本身，持有者
- signature: 服务器端对`header.payload`载荷签名: 1) hash计算， 2）私钥加密。
- 公钥解密，对数据作hash, 对比hash.



### envoy jwt

`envoy.filters.http.jwt_authn`, 配置此过滤器，就可以完成终端用户认证

- providers 如何验证jwt
- rules         定义检验标准

```yaml
http_filters:
- name:
  config:
    providers: [] # 如何验证jwt
    - name: '...' # provider名称
        issuer: '...' # 令牌签发者
        audiences: [] # jwt受众列表 属于当前列表中一个，就OK
        remote_jwks: '{...}' # https 获取jwks
        local_jwks: '{...}'  # 本地获取jwks; 文件或字符串
        forward: '...'       # 是否转发jwt 到后端。默认false, 不会转发到后端。
        from_headers: []     # 协议头获取token: Authorazation: Bear "<token>"
        from_params: []      # param获取jwt
        forward_payload_header: '...' # 如果forward为true时， 额外定义header, 来转发payload到后端
        payload_in_metadata: '...'
     rules: [] # jwt验证要求
     - match: '{...}' # 路由匹配的流量会进行JWT认证
       requires: {}     # 验证要求，以下验证方式只能使用其中一种
        provider_name: '...' # 使用哪个provider验证
        provider_and_audiences: '{...}' # 验证的provider必须明确指定包含哪些audiences.
        requires_any: '{...}'         # requirements参数provides列表，1个provider通过就通过
        requires_all: '{...}'         #  requirements参数provides列表，所有provider通过就通过
        allow_missing_or_failed: '{...}' # jwt缺失或验证失败，结果依然通过
        allow_missing: '{...}'
```

> 现在用户基于jwt算法生成jwt, 到了envoy之后，envoy就通过以上的方式来验证jwt, 验证通过就可以访问URL了

# authorization  授权

## RABC/ABAC

服务网格中的授权

- `RBAC` 控制粒度粗，只考虑group
- `ABAC` 比`RBAC`更高级的授权模型, 不仅考虑group, 还会检验用户提交的一些属性。

## 外部的授权

`envoy.ext_authz,` 请求来到envoy之后，envoy访问外部授权服务，获取请求是否有权限访问。

最为常用的`OPA(open policy agent)`组件, 策略引擎，完成策略检查，权限策略本身不带有。需要用户定义权限策略，这个引擎就会拿着策略对比。

使用高级声明性语言`Rego`(policy language)定义策略，常用于微服务、`kubernetes`、`ci/cd pipeline`、`api`网关等中实施策略。

外部服务定义为cluster.

`opa`  可以运行为sidecar，就可以给envoy sidecar提供授权。

`OPA`三个输入, 都必须是`Json`格式的数据

- 微服务请求时，带请求的属性给`OPA`
- `OPA`自己收到策略定义
- `OPA`自己的数据定义

![](https://github.com/open-policy-agent/opa-envoy-spire-ext-authz/raw/master/arch.png)

<div class="admonition note">
    https://github.com/open-policy-agent/opa-envoy-spire-ext-authz
</div>

将来`opa`以sidecar运行，而不是spire那样，合并程序为一个镜像

这里的实例，spire和`opa` 都融合了.

<div class="admonition warnging">
    将来真正使用时，`opa`会打包进容器，而spire-agent是在节点级别的。
	mixer提供`OPA`，不同节点使用不同node-id. 
    由于每一次请求都会进行检查OPA, 这也是mixer性能差的原因，所以我们<strong>很多时候不会开OPA</strong>
    istio环境中，一般在外部服务运行一个opa. 这个opa以mixer的适配器适配到外部实现.
</div>

## `RBAC`

界定谁可以以什么操作，操作什么对象

`envoy.filters.http.rbac`

```yaml
action: # 操作行为
policies:
  角色名称
  	permission: # 一个角色上的权限列表，或关系
  	  any: # true 所有权限
  	  headers: # 检验header
  	  ip
  	  port
  	  metadata
  	  server_name
  	  and_rule: {} # 上面与关系
  	  or_rile: {} # 上面或关系，默认情况就是或关系
	principals: # 这个角色在什么条件下有权限 
   	  认证的用户
      拥有header
      拥有元数据
```





# 示例

```bash
root@ip-10-0-0-245:~# ls -l servicemesh_in_practise-master/security/envoy-spire-ext-authz/
total 104
-rw-r--r-- 1 root root 11357 Apr 23  2020 LICENSE
-rw-r--r-- 1 root root  8631 Apr 23  2020 README.md
-rw-r--r-- 1 root root 51046 Apr 23  2020 arch.png
-rwxr-xr-x 1 root root   315 Apr 23  2020 build.sh
-rwxr-xr-x 1 root root  2306 Apr 23  2020 configure-spire.sh
drwxr-xr-x 8 root root  4096 Apr 23  2020 docker
-rw-r--r-- 1 root root  2985 Apr 23  2020 docker-compose.yml
-rw-r--r-- 1 root root  2651 Apr 23  2020 gencerts.go
drwxr-xr-x 5 root root  4096 Apr 23  2020 src
-rwxr-xr-x 1 root root   158 Apr 23  2020 start-spire-agent.sh

```

> ` cat docker/web/opa/policies/policy.rego `
>
> ```diff
> package envoy.authz
> 
> import input.attributes.request.http as http_request
> import input.attributes.source.address as source_address
> 
> default allow = false
> 
> allowed_paths = {"/hello", "/the/good/path", "/the/bad/path"}
> allowed_local_paths = {"/good/backend", "/good/db"}
> 
> # allow access to the Web service from the subnet 172.28.0.0/16 for the allowed paths
> allow {
> +    allowed_paths[http_request.path] # 允许来源路径
> +    http_request.method == "GET" # 允许方法
> +    net.cidr_contains("172.28.0.0/16", source_address.Address.SocketAddress.address) # 允许客户端源地址
> }
> 
> # allow Web service access from localhost for locally allowed paths
> allow {
>     source_address.Address.SocketAddress.address == "127.0.0.1"
>     allowed_local_paths[http_request.path]
>     http_request.method == "GET"
> }
> ```
>
> ` docker/backend/opa/policies/policy.rego`
>
> ```diff
> package envoy.authz
> 
> import input.attributes.request.http as http_request
> import input.attributes.source.address as source_address
> 
> default allow = false
> 
> # allow Web service to access Backend service
> allow {
>     http_request.path == "/good/backend"
>     http_request.method == "GET"
> +    svc_spiffe_id == "spiffe://domain.test/web-server" # 仅允许web-server请求
> }
> 
> # allow Backend service access from localhost
> allow {
> +    source_address.Address.SocketAddress.address == "127.0.0.1"
> +    http_request.path == "/good/db"     # 仅允许自己对good/db发起get请求
>     http_request.method == "GET"
> }
> 
> +svc_spiffe_id = client_id { # 获取spiffe_id的方式
>     [_, _, uri_type_san] := split(http_request.headers["x-forwarded-client-cert"], ";")
>     [_, client_id] := split(uri_type_san, "=")
> }
> 
> ```
>
> `docker/db/opa/policies/policy.rego`
>
> ```diff
> package envoy.authz
> 
> import input.attributes.request.http as http_request
> import input.attributes.source.address as source_address
> 
> default allow = false
> 
> # allow Backend service to access DB service
> allow {
>     http_request.path == "/good/db"
>     http_request.method == "GET"
>     svc_spiffe_id == "spiffe://domain.test/backend-server" # 允许这个来访问。spiffe_id, 就是backend-server
> }
> 
> svc_spiffe_id = client_id {
>     [_, _, uri_type_san] := split(http_request.headers["x-forwarded-client-cert"], ";")
>     [_, client_id] := split(uri_type_san, "=")
> }
> 
> ```

```bash
docker-compose up
```

spire的`svid`生成

```bash
cd servicemesh_in_practise-master/security/envoy-spire-ext-authz/
bash configure-spire.sh 
```

访问测试

```bash
root@ip-10-0-0-245:~/servicemesh_in_practise-master/security/envoy-spire-ext-authz# docker-compose ps
                Name                              Command               State                  Ports              
------------------------------------------------------------------------------------------------------------------
envoy-spire-ext-authz_api-server-1_1   flask run --host=0.0.0.0         Up       0.0.0.0:5000->5000/tcp           
envoy-spire-ext-authz_api-server-2_1   flask run --host=0.0.0.0         Up       0.0.0.0:5001->5000/tcp, 5001/tcp 
envoy-spire-ext-authz_backend_1        /bin/sh -c /usr/local/bin/ ...   Up       10000/tcp                        
envoy-spire-ext-authz_db_1             /bin/sh -c /usr/local/bin/ ...   Up       10000/tcp                        
envoy-spire-ext-authz_opa_be_1         ./opa_envoy_linux_amd64 -- ...   Exit 1                                    
envoy-spire-ext-authz_opa_db_1         ./opa_envoy_linux_amd64 -- ...   Exit 1                                    
envoy-spire-ext-authz_opa_web_1        ./opa_envoy_linux_amd64 -- ...   Exit 1                                    
envoy-spire-ext-authz_spire-server_1   /usr/bin/dumb-init /opt/sp ...   Up                                        
envoy-spire-ext-authz_web_1            /bin/sh -c /usr/local/bin/ ...   Up       10000/tcp, 0.0.0.0:8001->8001/tcp
```

```bash
curl localhost:5000
curl localhost:5001
curl localhost:5000/the/good/path # db允许backend-server访问
curl localhost:5000/the/bad/path # db仅允许backend-server访问
```

要实现灵活的策略，需要熟悉rego语言，对安全要求高的环境，可以。但是对性能影响非常大









