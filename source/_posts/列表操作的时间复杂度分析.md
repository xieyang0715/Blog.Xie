---
title: 列表操作的时间复杂度分析
date: 2021-01-13 01:51:29
tags:
---

python内建的函数，实现的算法的效率未必有我们自已写的算法效率高，所以**锻炼算法逻辑，自已实现函数**，要理解每个函数背后的时间复杂度。



时间复杂度：考量算法效率的指标，即算法花的步骤对应的时间，步骤多，时间越多，效率不高

使用**O**表示

1. **O(1)** 算法处理的数据规模增大，拿到结果只需要1步或有限几步。
2. **O(n)**  算法处理的数据规模增大，拿到结果只需要数据规模个数的步骤。一个for表示n, 2个for表示n^2, ...，所以for循环应该尽可能 的少。
3. **O(n^2)** 2个for
4. **O(logn)**

<!--more-->

列表特性

- [ ] **可变的**，可以随意添加元素。在一个列表中，如果在首部添加元素，会导致后面的元素向后挪动，内存中会进行调整效率低。insert(index)不建议使用。建议使用append()。

  但是link链表结构是手拉手，中间插入元素，只是前后的元素的手手拉着即可，不存在内存的挪动。

- [ ] **线性结构**，排序整齐，内存中也整齐，有偏移位置，所以查询效率**O(1)**

  但是链表，不能通过固定偏移查找，不能使用索引，只是有序的串在一起。所以链表的查询效率**O(n)**, 每次查询得遍历一次链表。

- [ ] 列表不可哈希

- [ ] 列表元素类型不固定

  



写程序时，你得考虑时间复杂度，index, count是否使用，用几次？

index, count  查询效率O(n), 所有元素全部遍历一次，才知道结果。看了n个元素，即时间为n。index虽然有时可能在第1次，但是index随着问题规模增加，一定在增加，可能在最后一个，那遍历的就越多，所以index是O(n)的问题。



列表是元数据记录长度，反复使用的数据要记录下来

len() 背后取的是对象的元数据



对列表有影响的方法, 内存会挪动

append()  时间复杂度O(1)，找到最后一个，因为固定偏移。

insert(index), index(0)整个列表会归整，时间复杂度O(1)，但是插入的位置会关键。**队列允许你两头做，有优化。**

remove() 如果清理一个元素，后面的元素会向前挪动，效率低。

pop()       默认尾部弹出O(1)，但是pop(index)，如果pop(0)就会导致整个列表元素向前挪动。

clear()     如果列表数据量大，所有元素的引用计数清零，可能触发python gc, 影响效率。

reverse()  中间的元素不动，两边的元素互相对调位置，所以迭代 n/2次，即可互换元素。

sort(key=None, reverse=False) key在复杂函数，或lambda表达式来处理，排序算法，必须掌握。你没有写过就写5遍。写过的，但是python实现，你没有写过啊！所以语言语法不一样，算法才是核心。

in



lst0 = lst2, 是复制内存地址，is, == 为True



lst2 = [1,[2,3],4]

lst0 = lst2.copy() 是复制复杂类型的地址，简单类型是复制内容, 复制结果 is为False, ==为True

```python
copy是浅拷贝，中间是复杂类型，引用类型，他直接拷贝地址。
引用：c/c++指针 
Java、高级语言是引用

复制不好，所有元素一起变化
复制好，就是一个小技巧
```



import copy

lst0 = copy.deepcopy(lst2) 无论什么类型都复制内容。 复制结果 is为False, ==为True

```python
深拷贝，就算复杂类型，也会单独拷贝一份引用类型
```













