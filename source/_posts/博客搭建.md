---
title: 博客搭建
date: 2021-09-09 22:06:58
tags:
- 黑马前端
---



# 博客预览

实现功能：

- 博客首页分页查看
- 管理员页面：
  - 用户管理：添加、修改、删除
  - 博客管理：添加、修改、删除、会关联哪个用户的博客
  - 写博客、上传附件
- 右上角会有用户信息和退出登陆

> 写一个博客时会关联一个用户，所以用户表和博客表有关联关系

[^467]:467

#  项目初始化

只有将这些做完了，才可以完成项目的具体功能。

1. 建立项目所需的文件夹

   - public 静态资源
   - model 数据库操作
   - route 路由
   - views模板

2. 初始化项目描述文件

   - npm init 

     生成根目录下的package.json

3. 下载项目所需的第3方模块

   ```bash
   npm install express mongoose art-template express-art-template
   ```

   `express` 后端

   `mongoose` 连接数据库，操作数据库

   `art-template`, `express-art-template` 渲染模板

4. 创建网站服务器
5.  构建模块化路由
6.  构建博客管理页面模板

[^468]: 468

## 建立博客

```bash
$ install -dv blog/{public,model,route,views}
```

## 生成项目的描述文件

```bash
cd blog
npm init -y
```

## 依赖

```bash
npm install express mongoose art-template express-art-template  --registry=http://r.npm.taobao.org/
```

下载的模板会记录在package.json文件中

## 创建网站服务器

```bash
touch app.js
```

`app.js`

```js
// 引用express框架
const express = require('express');
// 创建网站服务器
const app = express();


// 监听端口,开发3000, 上线后使用80
app.listen(80);
console.log('网站服务器启动成功，请访问 localhost:80')
```

启动服务器

```bash
$ npm install --save-dev nodemon  --registry=http://r.npm.taobao.org/
$ npm install -g nodemon  --registry=http://r.npm.taobao.org/

nodemon app.js
```

> nodemon好处，修改文件时，可以热加载文件

## 模板化路由

当前是展示页面、管理页面。需要区分开

```bash
// 展示页面
touch blog/route/home.js

// 管理页面
touch blog/route/admin.js
```

展示页面 `home.js`

```bash
// 引用express框架
const express = require('express');

// 创建博客展示页面路由, 返回路由对象
const home = express.Router();

home.get('/', (req, res)=> {
	res.send('欢迎来到博客首页')
});

// 将路由对象作为模块成员进行导出
module.exports = home;
```

管理页面`admin.js`, 复制以上代码，修改home为admin,  发送的文字修改一下即可。

app导入路由 `app.js` 文件中，在`app.listen()`之上，`const app = express()`之下 ，粘贴以下代码

```js
// 引入路由模块
const home = require('./route/home');
const admin = require('./route/admin');
```

> require可以省略js后缀。require返回module.exports对象即就是路由对象。

在以上代码之下，粘贴以下代码，生成路由

```js
// 为路由对象映射请求路径
app.use('/home', home);
app.use('/admin', admin);
```

现在在浏览器中，输入`localhost`,  路由是/home就是到达一级路由的/home, 并到二级的/. admin同理。

## 构建模板文件

### 准备静态文件

此模板来自`黑马前端2019就业班视频教程` 中

`11-16 前后端交互\11-13node+express\day06\code\静态页面\blog`

`public/home` 博客的展示页面

```bash
$ ls public/home/
article.html  css/  default.html  images/  js/  lib/
```

`public/admin`博客的管理页面

```bash
$ ls public/admin/
article-edit.html  css/     js/   login.html      user.html
article.html       images/  lib/  user-edit.html
```

`app.js`文件中在`const app = express();` 下方，粘贴以下内容

```bash
// 开放静态资源文件, 拦截请求给express处理
app.use(express.static(path.join(__dirname,'./public'))) 
```

并在文件首部添加以下内容，来引入新的path模块, 确保可以拼接路径

```bash
// 处理路由的模块
const path = require('path');
```

现在访问此框架提供的静态文件，`http://localhost/home/default.html`

![image-20210910135335451](http://myapp.img.mykernel.cn/image-20210910135335451.png)

### 准备模板

以上，已经将静态文件发布成功了，但是`css/js/image`确实是静态资源文件，但是html文件不能是静态资源文件。因为在html文件中需要拼上从数据库中查询出来的数据。

转换home目录下的html为动态模板

```bash
$ install -dv views/{home,admin}
$ mv public/home/*.html views/home/
$ mv public/admin/*.html views/admin/
```

由于此模板引擎要求后缀为`.art`

```bash
$ for i in `find views/ -name *.html` ; do basename=$(basename $i .html);  dir=$(dirname $i); mv $i ${dir}/${basename}.art ; done
```

```bash
$ ls views/home/
article.art  default.art
$ ls views/admin/
article-edit.art  article.art  login.art  user-edit.art  user.art
```

### 渲染模板

先做admin

当用户访问`/admin/login`, 就渲染`login.art`. 现在访问没有页面。

![image-20210911160916174](http://myapp.img.mykernel.cn/image-20210911160916174.png)

编辑`route/admin.js`

```js
// 引用express框架
const express = require('express');

// 创建博客展示页面路由, 返回路由对象
const admin = express.Router();

admin.get('/login', (req, res)=> {
        res.render('admin/login')
});

// 将路由对象作为模块成员进行导出
module.exports = admin;
```

> 模板是`res.render()`方法渲染，模板应该使用绝对路径，由于我们需要写大量**模块路由**中渲染的模板的路径(public/*)，所以可以由`express` 服务器来配置render方法的起始路径及默认后缀, 并配置不同后缀指定不同的引擎来渲染。
>
> 在`app.js`文件中，`const app = express();`创建服务器紧挨着的下方，配置静态页面的上方，粘贴以下内容
>
> ```js
> // 配置express框架，模板基础位置，及其默认后缀. 配置指定后缀使用什么模板引擎
> app.set('views', path.join(__dirname, './views')); // first arg: views固定, 模板位置
> app.set('view engine', 'art'); // second arg: 模板固定后缀
> app.engine('art', require('express-art-template')); //first arg: 什么后缀；second arg: 指定什么引擎
> ```

现在两次访问`/admin/login`, 查看渲染出来的登陆页面如下

![image-20210910141959610](http://myapp.img.mykernel.cn/image-20210910141959610.png)

[^469]: 469static

 ### 模板文件中静态资源要使用绝对路径

[^470]:470

1. 现在我们浏览器请求`localhost/admin/login/`

   现在可以发现浏览器展示的页面不一样了，因为页面渲染需要html和css, image, js..., 现在原因是css/image/js文件没有加载到。

   ![image-20210911163401063](http://myapp.img.mykernel.cn/image-20210911163401063.png)

2. 通过 鼠标右键，查看网页源代码.

   可以发现，网页源代码和之前的/admin/login是一模一样的，我们可以重复打开 /admin/login页面，进行 鼠标右键，查看网页源代码，是一模一样的。

   但是为什么就没有了资源了呢？将鼠标悬浮在href的链接上（即下方的链接上），可以发现浏览器左下角显示此绝对URL是`localhost/admin/login/...`

   通过express框架的app.js模板中定义的静态资源路径应该是`/admin/lib/bootstrap/css/bootstrap.min.css` ，所以没有加载到。而且我们使用正确的`localhost/admin/login`路径查看的源码，获取的路径中没有login.

   所以浏览器解析相对路径时，是按照路径是否/结尾来确定静态资源的路径。为了避免用户使用了不期望的URL，加载不到静态资源，所以我们可以使用绝对路径的静态资源引用 。

   ![image-20210911163655272](http://myapp.img.mykernel.cn/image-20210911163655272.png)

   此图为/admin/login的源码

![image-20210911162835710](http://myapp.img.mykernel.cn/image-20210911162835710.png)

​	

3. 修改网页的源码为绝对路径. 使用绝对路径时，使用/起始，后面的路径就是public目录下的路径.

   修改`views/admin/login.art` 

   ```html
       <link rel="stylesheet" href="/admin/lib/bootstrap/css/bootstrap.min.css">
       <link rel="stylesheet" href="/admin/css/base.css">
   
   
       <script src="/admin/lib/jquery/dist/jquery.min.js"></script>
       <script src="/admin/lib/bootstrap/js/bootstrap.min.js"></script>
   ```

   

4. 现在我们修改`app.js`的路由`app.use('/admin', admin);` 为以下行时，现在访问admin路由中的login目录，

   ```js
   app.use('/abc', admin);
   ```

5. 请求 `localhost/abc/login`，右边是浏览器F12，打开并选择`Network`的结果，如果点一个蓝色栏的地方，也会出现请求的路径。

   ![image-20210911164751793](http://myapp.img.mykernel.cn/image-20210911164751793.png)

​	现在请求的路径就是:![image-20210911164847189](http://myapp.img.mykernel.cn/image-20210911164847189.png)

6. 现在将所有`views/admin/*.art`目录下的所有`src="`或`href="` 其后面加`/admin/`绝对起始目录

   ```bash
   $ find  views/admin/ -type f ! -name login.art -exec sed -i 's@src="\|href="@&/admin/@g' {}  \;
   ```

   同样`views/home`也一样

   ```bash
   $ find  views/home/ -type f -exec sed -i 's@src="\|href="@&/home/@g' {}  \;
   ```

7. 恢复路由为/admin起始的路径, 参考第4步

### 抽取模板的公共部分到单独的文件中

[^471]: 471

1. 观察相同点

   首先同时打开``11-16 前后端交互\11-13node+express\day06\code\静态页面\blog\admin` 中的所有html。选中所有，右键打开即可

   通过观察，所有页面的头、侧边栏一致。但是login.html页面并不一样。

   示例：打开admin/user.html页面，通过F12, 选中`elements`， 如下。通过发现这些部分是对应的就是左侧栏和顶部栏

   ![image-20210911172802180](http://myapp.img.mykernel.cn/image-20210911172802180.png)

2. 抽出相同的部分为模板

   准备admin的header和aside的通过模板

   ```bash
   $ install -dv views/admin/common/
   $ touch views/admin/common/header.art
   $ touch views/admin/common/aside.art
   ```

   鼠标放在上面的header行，右键复制。将header部分放在`header.art`中

   ```html
   <div class="header">
       	<!-- 网站标志 -->
           <div class="logo fl">
             黑马程序员 <i>ITHEIMA</i>
           </div>
           <!-- /网站标志 -->
           <!-- 用户信息 -->
           <div class="info">
               <div class="profile dropdown fr">
                   <span class="btn dropdown-toggle" data-toggle="dropdown">
   					admin
   					<span class="caret"></span>
                   </span>
                   <ul class="dropdown-menu">
                       <li><a href="user-edit.html">个人资料</a></li>
                       <li><a href="#">退出登录</a></li>
                   </ul>
               </div>
           </div>
           <!-- /用户信息 -->
       </div>
   ```

   同理复制侧边栏放在`aside.art`中

   ```html
   <div class="aside fl">
       <ul class="menu list-unstyled">
           <li>
               <a class="item active" href="user.html">
                   <span class="glyphicon glyphicon-user"></span>
                   用户管理
               </a>
           </li>
           <li>
               <a class="item" href="article.html">
                   <span class="glyphicon glyphicon-th-list"></span>
                   文章管理
               </a>
           </li>
       </ul>
       <div class="cprt">
           Powered by <a href="http://www.itheima.com/" target="_blank">黑马程序员</a>
       </div>
   </div>
   ```

3. 修改`admin/user.art`, 并验证是否正常

   现在修改`public/admin/user.art` 使用模板语法引用header, aside。 先折叠

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
       <title>Blog - Content Manager</title>
       <link rel="stylesheet" href="/admin/lib/bootstrap/css/bootstrap.min.css">
       <link rel="stylesheet" href="/admin/css/base.css">
   </head>
   
   <body>
   	<!-- 头部 -->
       {{ include './common/header.art' }}
       <!-- /头部 -->
       <!-- 主体内容 -->
       <div class="content">
       	<!-- 侧边栏 -->
           {{ include './common/aside.art' }}
           <!-- 侧边栏 -->
           <div class="main">
           	<!-- 分类标题 -->
               <div class="title">
                   <h4>用户</h4>
                   <span>找到1个用户</span>
                   <a href="/admin/user-edit.html" class="btn btn-primary new">新增用户</a>
               </div>
               <!-- /分类标题 -->
               <!-- 内容列表 -->
               <table class="table table-striped table-bordered table-hover custom-table">
                   <thead>
                       <tr>
                           <th>ID</th>
                           <th>用户名</th>
                           <th>邮箱</th>
                           <th>角色</th>
                           <th>状态</th>
                           <th>操作</th>
                       </tr>
                   </thead>
                   <tbody>
                       <tr>
                           <td>5b9a716cb2d2bf17706bcc0a</td>
                           <td>wangjian</td>
                           <td>wjb19891223@163.com</td>
                           <td>超级管理员</td>
                           <td>正常</td>
                           <td>
                               <a href="/admin/user-edit.html" class="glyphicon glyphicon-edit"></a>
                               <i class="glyphicon glyphicon-remove" data-toggle="modal" data-target=".confirm-modal"></i>
                           </td>
                       </tr>
                       <tr>
                           <td>5b9a716cb2d2bf17706bcc0a</td>
                           <td>wangjian</td>
                           <td>wjb19891223@163.com</td>
                           <td>普通用户</td>
                           <td>禁用</td>
                           <td>
                               <a href="/admin/user-edit.html" class="glyphicon glyphicon-edit"></a>
                               <i class="glyphicon glyphicon-remove" data-toggle="modal" data-target=".confirm-modal"></i>
                           </td>
                       </tr>
                       <tr>
                           <td>5b9a716cb2d2bf17706bcc0a</td>
                           <td>wangjian</td>
                           <td>wjb19891223@163.com</td>
                           <td>普通用户</td>
                           <td>启用</td>
                           <td>
                               <a href="/admin/user-edit.html" class="glyphicon glyphicon-edit"></a>
                               <i class="glyphicon glyphicon-remove" data-toggle="modal" data-target=".confirm-modal"></i>
                           </td>
                       </tr>
                   </tbody>
               </table>
               <!-- /内容列表 -->
               <!-- 分页 -->
               <ul class="pagination">
                   <li>
                       <a href="/admin/#">
   			        <span>&laquo;</span>
   			      </a>
                   </li>
                   <li><a href="/admin/#">1</a></li>
                   <li><a href="/admin/#">2</a></li>
                   <li><a href="/admin/#">3</a></li>
                   <li><a href="/admin/#">4</a></li>
                   <li><a href="/admin/#">5</a></li>
                   <li>
                       <a href="/admin/#">
   			        <span>&raquo;</span>
   			      </a>
                   </li>
               </ul>
               <!-- /分页 -->
           </div>
       </div>
       <!-- /主体内容 -->
       <!-- 删除确认弹出框 -->
       <div class="modal fade confirm-modal">
           <div class="modal-dialog modal-lg">
               <form class="modal-content">
                   <div class="modal-header">
                       <button type="button" class="close" data-dismiss="modal"><span>&times;</span></button>
                       <h4 class="modal-title">请确认</h4>
                   </div>
                   <div class="modal-body">
                       <p>您确定要删除这个用户吗?</p>
                   </div>
                   <div class="modal-footer">
                       <button type="button" class="btn btn-default" data-dismiss="modal">取消</button>
                       <input type="submit" class="btn btn-primary">
                   </div>
               </form>
           </div>
       </div>
       <!-- /删除确认弹出框 -->
       <script src="/admin/lib/jquery/dist/jquery.min.js"></script>
       <script src="/admin/lib/bootstrap/js/bootstrap.min.js"></script>
   </body>
   
   </html>
   ```

    > 写相对路径，就是相对当前路径，因为是模板引擎来解析的。

    现在验证此模板是否正常，通过 [渲染模板](#渲染模板)方式，在route/admin.js中引入新的路由, 即在 `module.exports = admin;` 之前粘贴以下内容

    ```js
    admin.get('/user', (req, res)=> {
        res.render('admin/user')
    });
    ```

    现在浏览器访问`localhost/admin/user`
   
   ![image-20210911174712102](http://myapp.img.mykernel.cn/image-20210911174712102.png)

4. 按照第3步，修改所有views/admin/下面其他的非`login.art`的art文件

   同时在需要`route/admin.js` 的`module.exports = admin;` 前粘贴以下路由。

   ```js
   admin.get('/user-edit', (req, res)=> {
   	res.render('admin/user-edit')
   });
   
   admin.get('/article', (req, res)=> {
   	res.render('admin/article')
   });
   admin.get('/article-edit', (req, res)=> {
   	res.render('admin/article-edit')
   });
   ```

   验证访问

   

### 抽取模板的骨架

[^472]: 472

1. 抽取骨架

     header和body的部分, 基于user-edit.art模板，抽取非header, 非主体内容的其他内容，为骨架

   ```bash
   $ touch views/admin/common/layout.art
   ```

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
       <title>Blog - Content Manager</title>
       <link rel="stylesheet" href="/admin/lib/bootstrap/css/bootstrap.min.css">
       <link rel="stylesheet" href="/admin/css/base.css">
   </head>
   
   <body>
       <!-- 头部 -->
       <!-- /头部 -->
       <!-- 主体内容 -->
       <!-- /主体内容 -->
       <script src="/admin/lib/jquery/dist/jquery.min.js"></script>
       <script src="/admin/lib/bootstrap/js/bootstrap.min.js"></script>
   </body>
   
   </html>
   ```

   现在每一个页面都有自己的css文件，自己的头部，自己的主体，自己的脚本。此处使用{{block}}语法

   ```html
   <!DOCTYPE html>
   <html lang="en">
   
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
       <title>Blog - Content Manager</title>
       <link rel="stylesheet" href="/admin/lib/bootstrap/css/bootstrap.min.css">
       <link rel="stylesheet" href="/admin/css/base.css">
   
       {{ block 'link' }} {{ /block }}
   </head>
   
   <body>
       {{ block 'main' }} {{ /block }}
       <script src="/admin/lib/jquery/dist/jquery.min.js"></script>
       <script src="/admin/lib/bootstrap/js/bootstrap.min.js"></script>
       {{ block 'script' }} {{ /block }}
   </body>
   
   </html>
   ```

    > `{{ block 'link' }} {{ /block }}`
    >
    > `{{ block 'main' }} {{ /block }}`
    >
    > `{{ block 'script' }} {{ /block }}`

2. 以`views/admin/user.art`，可以继承骨架文件。

     先删除user.art与layout.art相同的部分。通过`beyond compare`比较。

     将左侧的白色，即相同的部分，删除。并在行首添加，引入骨架的语法：`{{ extend './common/layout.art' }}`

     然后左侧红色部分对应右侧是`{{ block 'main' }} {{ /block }}` 时，就使用这个包装左侧的红色部分。

     ![image-20210911182219060](http://myapp.img.mykernel.cn/image-20210911182219060.png)

     最终如下：

     ```html
     {{ extend './common/layout.art' }}
     {{ block 'main' }}
         <!-- 头部 -->
         {{ include './common/header.art' }}
         <!-- /头部 -->
         <!-- 主体内容 -->
         <div class="content">
         	<!-- 侧边栏 -->
             {{ include './common/aside.art' }}
             <!-- 侧边栏 -->
             <div class="main">
                 ...
             </div>
         </div>
         <!-- /主体内容 -->
         <!-- 删除确认弹出框 -->
         <div class="modal fade confirm-modal">
             <div class="modal-dialog modal-lg">
                 <form class="modal-content">
                     <div class="modal-header">
                         <button type="button" class="close" data-dismiss="modal"><span>&times;</span></button>
                         <h4 class="modal-title">请确认</h4>
                     </div>
                     <div class="modal-body">
                         <p>您确定要删除这个用户吗?</p>
                     </div>
                     <div class="modal-footer">
                         <button type="button" class="btn btn-default" data-dismiss="modal">取消</button>
                         <input type="submit" class="btn btn-primary">
                     </div>
                 </form>
             </div>
         </div>
         <!-- /删除确认弹出框 -->
     {{ /block }}
     ```

     现在浏览器中去验证这个`/admin/user`路由是否是正常的。

     ![image-20210911182909360](http://myapp.img.mykernel.cn/image-20210911182909360.png)

3. 参考第2步，修改article-edit.art文件。 其他文件同此，一并修改。

   可以发现，beyond compare比较时，多出一点脚本

   ![image-20210911183338080](http://myapp.img.mykernel.cn/image-20210911183338080.png)

   然后直接将右侧的block复制过来, 使用block包装新的脚本，说明新的脚本已经通过block块加载

   ![image-20210911183429532](http://myapp.img.mykernel.cn/image-20210911183429532.png)

   最后将在第1行继承骨架`{{ extend './common/layout.art' }}`, 代码略

   访问结果：

   ![image-20210911183653395](http://myapp.img.mykernel.cn/image-20210911183653395.png)

   

# 项目初始化

## 准备环境

[^473]: 473

1. 准备Monogo数据库

   准备使用docker安装mongodb，由于本电脑是 win10, 所以先进行[Windows Docker 安装](https://www.runoob.com/docker/windows-docker-install.html), 然后再[*Docker* 安装 *MongoDB* | 菜鸟教程](https://www.baidu.com/link?url=3AkDjhBWUVRVWF-Bq0nZsQA_-XgXEIxqtrUJl91LJDPI347YU9D30Ne5SIzA94YiRVP51sTHxeDNayYpIKIDc-FGXyQHTaRUZYzTeYuT3na&wd=&eqid=eb25c7d30051fa1b00000002613d4b9d)

   测试使用的目的，不加认证

   ```bash
   docker run -itd --name mongo -p 27017:27017 mongo
   ```

## 准备用户

[^474]: 474



1. 初始化用户

```bash
$ touch model/{connect.js,user.js}
```

> connect.js 连接数据库
>
> user.js 初始化用户

`connect.js`

```js
// 连接数据库的模块 

// 引入mongoose第3方模块 
const mongoose = require('mongoose');

// 连接数据库.
mongoose.connect('mongodb://localhost/blog').then(
                                                  () => console.log('db conn success.')).catch(
                                                  () => console.log('db conn failed.'))  
```

> `'mongodb://localhost/blog` 当前没有blog数据库，插入文档会自动建立
>
> then表示成功
>
> catch表示失败
>
> 当前只是模块，需要连接时，应该在入口`app.js`文件紧挨着`const app = express();` 下面引入连接mongo数据库
>
> ```js
> // 数据库连接
> require('./model/connect');
> ```
>
> > 由于此模块并不导出，所以不需要变量接
>
> 当我们修改主文件，会自动重载，命令行会有以下提示
>
> ```bash
> db conn success. 
> ```
>

现在需要初始化`user.js`

此用户表需要什么字段呢？访问`http://localhost/admin/user-edit`

![image-20210912091030124](http://myapp.img.mykernel.cn/image-20210912091030124.png)

> 用户名：显示在右上角的昵称
>
> 邮箱：用来登陆 
>
> 密码：前期不加密
>
> 角色：普通用户、超级管理员
>
> 用户状态：启用：可以登陆，可以操作。禁用：不能登陆，不可以相应操作

2. 准备用户的数据结构，到底什么结构，观察`http://localhost/admin/user-edit`
   现在创建user表集合 `user.js`

```js
// 创建用户集合

// 引入mongoose第3方模块 
const mongoose = require('mongoose');


// 创建用户集合规则
const userSchema = new mongoose.Schema({
	username: {
		type: String,   // 用户字符串
		required: true, // 用户注册时必须是存在的，存在undefined/null也可以，所以指定长度
		minlength: 2,
		maxlength: 20
	},
	email: {
		type: String,
		required: true,
		unique: true  // 每个用户的邮箱惟一
	},
	password: {
		type: String,
		required: true
	},
	role: {
		type: String,
		required: true
	},
	state: {
		type: Number, // 人为规定：0 启用状态，1禁用状态
		default: 0
	}
});

// 创建集合, 返回集合构建函数，通过函数可以操作集合
const User = mongoose.model('User', userSchema);

// 路由中需要对用户进行增删改查的操作, 由于以后可能会暴露其他对象，所以暴露一个对象的属性为User; ES6 中 对象键值一样时，可以简写为仅写值。
// module.exports = User;
module.exports = {
	User
};
```

> - 创建用户集合
> - 导出用户以便路由中增删改查用户

3. 初始化超级管理员, 在`const User = mongoose.model('User', UserSchema);` 紧接着的下方粘贴以下代码

```js
User.create({
	username: 'itheima',
	email: 'itheima@itcast.cn',
	password: '12345',
	role: 'admin',
	state: 0
}).then(() => {
	console.log('用户创建成功')
}).catch( () => {
	console.log('用户创建失败')
});

```

让此文件运行，将此`user.js`在`app.js`仅运行一次。在`require('./model/connect');` 之后粘贴以下代码

```js
require('./model/user');
```

现在控制台显示

```bash
[nodemon] starting `node app.js`
网站服务器启动成功，请访问 localhost:80
mongo db connect success.
用户创建成功
```

> 在windows控制台仅需要 选中后，右键一下即可以复制

使用`navicat 15.09`连接`mongodb`, 可以发现生成了`blog`数据库，users表

![image-20210913100158047](http://myapp.img.mykernel.cn/image-20210913100158047.png)

4. 注释第3步添加的**所有测试代码**，因为只需要第一次运行时有超级用户，后面这个用户操作仅在**路由中进行增删除改查**



## 登录

[^475]: 475

### 登录流程

| 步骤  | 用户                       | 开发                                                         |
| ----- | -------------------------- | ------------------------------------------------------------ |
| 第1步 | 填写用户和密码             | 1. 填写完，需要验证，如果用户不填写就要阻止表单提交。<br/> 2. 不需要验证邮箱地址的格式，密码的长度。 为什么？正常流程中，用户先注册而后登陆，注册时就验证了邮箱的格式及密码的复杂度。 |
| 第2步 | 提交，提交到哪个服务器地址 | 1. 服务器端**实现登陆的路由地址**，并指定请求方式为POST方式(安全)<br/> 2. 接受用户的传递来的请求参数。<br /> 3. 再次进行用户**请求参数的验证**。为什么？客户端使用`javascript`代码验证，一旦用户禁用了`javascript`代码，客户端验证就失效了。<br />  4. 用户验证通过，就通过邮箱**获取用户信息**。如果没有找到，说明用户的邮箱是错误的，就阻止程序向下运行，并响应客户端**邮箱地址或密码**错误。为什么不告诉直接说明邮箱地址错误呢？如果有人恶意猜测时，我们非常诚实的说，是邮件错误了，就降低了破解的难度，所以无论什么错误，均告诉用户，客户端**邮箱地址或密码**错误。<br/> 5. **用户查询到了，就将用户在表单中填写的密码和数据库查询出来的密码比对**。比对成功就说明登陆成功。比对失败，就说明登录失败。都需要给用户响应。 |

### 用户登录

实现登录`views/admin/login.art`

1. 找到登录表单

   ```html
                   <form action="user.html">
                       <div class="form-group">
                           <label>邮件</label>
                           <input type="email" class="form-control" placeholder="请输入邮件地址">
                       </div>
                       <div class="form-group">
                           <label>密码</label>
                           <input type="password" class="form-control" placeholder="请输入密码">
                       </div>
                       <button type="submit" class="btn btn-primary">登录</button>
                   </form>
   ```

2. 设置提交到哪个地址, 并使用post方法

   需要设置name属性(属性名最好和数据库的字段名一致)，这样服务端接受到时，就可以直接读name属性，否则就读取不到数据。

   ```diff
   +                <form action="/login" method="post">
                       <div class="form-group">
                           <label>邮件</label>
   +                        <input name="email" type="email"  class="form-control" placeholder="请输入邮件地址">
                       </div>
                       <div class="form-group">
                           <label>密码</label>
   +                        <input name="password" type="password" class="form-control" placeholder="请输入密码">
                       </div>
                       <button type="submit" class="btn btn-primary">登录</button>
                   </form>
   ```

   > 第1行是路由地址(用户请求的/admin/login所以这里请求的是)和请求方法
   >
   > 第4行是name=email
   >
   > 第8行是name=password

3. 对用户提交的表单验证 [^476]

   用户一提交就会发送数据了，所以需要给提交按键添加一个提交事件处理函数。先阻止表单默认提交的行为，先进行校验，而后让表单继续。

   在以下脚本段下面引入`<script`标签，由于页面现有的脚本有jquery脚本，所以我们就可以写jquery脚本了

       <script src="lib/jquery/dist/jquery.min.js"></script>
       <script src="lib/bootstrap/js/bootstrap.min.js"></script>

   ```html
       <script type="text/javascript">
           
       </script>
   ```

   > 此为我们添加的`script`标签

   现在为表单添加提交事件，1）获取表单； 2）添加事件

   - 获取表单

     要获取表单，就需要在`<form action="/login" method="post">` 表单的首行添加`id`

     ```bash
     <form action="/login" method="post" id="loginForm">
     ```

     然后在以上我们添加的`script`标签中添加jquery脚本, 获取form表单

     ```html
         <script type="text/javascript">
             $('#loginForm')
         </script>
     ```

   - 添加提交事件及对应的处理函数

     1. 阻止默认提交

     ```html
         <script type="text/javascript">
             $('#loginForm').on('submit', function () {
                 // 阻止表单默认提交的行为
                 // return false;
             });
     ```

     > 注意，现在并没有阻止，因为以上代码是注释的。我们访问`localhost/admin/login` 直接点提交. 可以发现直接跳转到以下页面
     >
     > ![image-20210913103958195](http://myapp.img.mykernel.cn/image-20210913103958195.png)

     现在取消注释`return false`,  重新刷新页面`localhost/admin/login`, 点登陆，并不会跳转。

     2. 获取表单数据

     现在就是获取表单的数据，进行验证了。通常可以给表单添加`id`属性，获取到属性(name对应的值)对应的表单控件进行验证，但是当表单比较多时，代码就啰嗦了。当前可以使用一个方法(`jquery`提供的 `serializeArray()`返回一个数组，其中包含多个表单控件的对象)，可以获取到表单控件的所有数据。

     获取在`return false`即阻止表单默认提交行为之上粘贴以下代码

     ```html
                 // 获取表单的用户输入内容
                 // [ {name: 'email', value: '用户输入的内容'}, ..]
                 var  f = $(this).serializeArray() // $(this) 即当前获取的表单
                 console.log(f) // 浏览器F12, console查看
     ```

     > 保存以上代码后，重新刷新浏览器，输入邮箱和密码，并点登录后F12中可以查看到获取到的表单数据.
     >
     > ![image-20210913105204686](http://myapp.img.mykernel.cn/image-20210913105204686.png)
     >
     > > 表单当中name属性的值，value的值就是表单当中输入的值

     3. 优化表单数据

        现在的数据如上，但是我们期望是返回`{'email': '', 'password': ''}`, 接下来自己实现转化

        现在将以上的`script`标签修改为以下代码

        ```html
            <script type="text/javascript">
                function serializeToJson(form) {
                    var result = {};
                    // [ {name: 'email', value: '用户输入的内容'}, ..]
                    var  f = form.serializeArray(); // $(this) 即当前获取的表单, form就是传递过来的form表单
                    f.forEach(function (item) { // item就是一个对象
                        result[item.name] = item.value; // 相当于 result.email = xxx
                    });
                    return result;
                }
                $('#loginForm').on('submit', function () {
                    // 获取表单的用户输入内容
                    var result = serializeToJson($(this)); // $(this) 即当前获取的表单
                    console.log(result) // 浏览器F12, console查看
        
                    // 阻止表单默认提交的行为
                    return false;
                });
            </script>
        ```

        > - 传递表单对应给函数。
        > - 函数中获取数组。
        > - 遍历数组，每个item就是每一个元素。然后把元素的key, value给result对象。

        现在刷新页面，再次输入，查看控制台的结果

        ![image-20210913111137135](http://myapp.img.mykernel.cn/image-20210913111137135.png)

     4. 真实项目的中，对表单处理是非常常见的事情，所以这个方法，应该变成公共的方法

        **剪切**以上的`serializeToJson`函数到文件`public/admin/js/common.js`

        ```js
                function serializeToJson(form) {
                    var result = {};
                    // [ {name: 'email', value: '用户输入的内容'}, ..]
                    var  f = form.serializeArray(); // $(this) 即当前获取的表单
                    f.forEach(function (item) { // item就是一个对象
                        result[item.name] = item.value; // 相当于 result.email = xxx
                    });
                    return result;
                }
        ```

        然后在login.art中引入新的script脚本, 紧挨着其它的`script`标签的下方，粘贴以下内容

        ```html
            <script src="/admin/js/common.js"></script>
        ```

        > 保存后，浏览器中验证`localhost/admin/login`页面，刷新页面后，填写邮箱和密码，再提交看看输出。

        其它的模板文件，都继承了`layout.art`模板，所以仅需要在模板中引入新脚本

        ```diff
        <body> 
            {{ block 'main' }} {{ /block }}
            <script src="/admin/lib/jquery/dist/jquery.min.js"></script>
            <script src="/admin/lib/bootstrap/js/bootstrap.min.js"></script>
        +    <script src="/admin/js/common.js"></script>
            {{ block 'script' }} {{ /block }}
        </body>
        ```

     5. 验证用户的输入内容

        现在login.art的新的`script`标签中代码如下

        ```html
            <script type="text/javascript">
        
                $('#loginForm').on('submit', function () {
                    // 获取表单的用户输入内容
                    var result = serializeToJson($(this));
                    console.log(result) // 浏览器F12, console查看
        
        
                    // 阻止表单默认提交的行为
                    return false;
                });
            </script>
        ```

        在`script`中验证邮件和密码不存在的情况，抛出提示。在最终的return false之前粘贴以下代码

        ```html
        
                    // if (result.email.trim().length > 0) { // trim() 去除空格。  验证用户输入了邮箱地址
        
                    // } 
        
                    if (result.email.trim().length == 0) { // 先判断用户没有输入地址，即以上的相反情况，就阻止程序向下执行
                        alert('请输入邮箱地址');
                        return false; // 阻止了执行时，并且阻止提交。 如果直接写return, 代码阻止执行，但是表单会提交。
                    }
        
                    if (result.password.trim().length == 0) { 
                        alert('请输入密码');
                        return false;
                    }
        ```

        > 现在浏览器，可以验证提交会提示，全部填写后就没有提示了。

        注释最后一行的测试，进行用户填写的数据验证后，就提交。重新刷新页面验证

        ![image-20210913113749564](http://myapp.img.mykernel.cn/image-20210913113749564.png)

     客户端登陆功能已经完成，接下来就需要在服务端完成登陆的路由

### 服务端的登录路由

[^477]:

#### 配置路由

   1. 登录路由

   先把login.art的表单修改成请求`/admin/login`

   ```html
                   <form action="/admin/login" method="post" id="loginForm">
   ```

   2. 添加路由。post `/admin/login`

      编辑`route/admin.js`, 在`admin.get('/login'`函数后面粘贴以下代码

      ```js
      // 实现登录功能
      admin.post('/login', (req, res)=> {
      	// 接收请求参数
      	res.send(req.body)
      });
      ```

      > 解析参数模块 `body-parser`， 中断运行服务器，先安装第3方模块
      >
      > ```bash
      > npm install --save body-parser
      > ```
      >
      > 然后在重启`nodemon app.js`
      >
      > 需要解析body, 需要在express入口处处理， 并会在req中添加body属性，就是用户填写的数据，编辑`app.js` 先首行引入body-parser
      >
      > ```js
      > // 引入body-parser, 处理post请求参数
      > const bodyParser = require('body-parser');
      > ```
      >
      > 然后处理post请求参数，在`const app = express();`紧挨着之后粘贴以下代码
      >
      > ```js
      > //处理post请求参数, 使用app.use中间件， 可以拦截所有请求，交给parser
      > app.use(bodyParser.urlencoded({extended: false})); // extended false 官方推荐
      > ```

      现在浏览器登录，可以看到我们输入的内容

      ![image-20210913115344342](http://myapp.img.mykernel.cn/image-20210913115344342.png)

#### 对请求参数二次验证

客户端验证不靠谱， 在浏览器的F12中，使用`ctrl+shift + P`， 输入`disable javascript`

再次登录，可以发现以下结果。![image-20210913120012826](http://myapp.img.mykernel.cn/image-20210913120012826.png)

> 说明虽然定义了javascript, 但是没有执行，后端则也需要检验

编辑`route/admin.js`, 修正/login的post路由

```js
// 实现登录功能
admin.post('/login', (req, res)=> {
	// 接收请求参数
	const {email, password} = req.body;

	if (email.trim().length == 0) {
		// 客户端请求格式问题
		return res.status('401').send('<h4>邮件地址或密码错误</h4>');
	}
});
```

> 现在请求页面将会报错用户及密码错误

同样，密码也一样，所以最终

```js
// 实现登录功能
admin.post('/login', (req, res)=> {
	// 接收请求参数
	const {email, password} = req.body;

	if (email.trim().length == 0 || password.trim().length == 0) {
		// 客户端请求格式问题
		return res.status('401').send('<h4>邮件地址或密码错误</h4>');
	}
});
```

> if中的代码只有1句时，可以省略`{}`

   1. 美化响应结果

      现在的结果响应的是`<h4>`太丑了。所以需要准备一个error模板, 编辑`views/admin/error.art`

      ```js
      {{ extend './common/layout.art' }}
      
      {{ block 'main' }}
      	<p class='bg-danger error'>错误提示</p>
      {{ /block }}
      ```

      直接render此模板即可

      ```js
      // 实现登录功能
      admin.post('/login', (req, res)=> {
      	// 接收请求参数
      	const {email, password} = req.body;
      
      	if (email.trim().length == 0 || password.trim().length == 0) {
      		// 客户端请求格式问题
      		return res.status('401').render('admin/error', {msg: '邮件地址或密码错误'});
      	}
      });
      ```

      > 传递给模板的数据， 并在`views/admin/error.art`中渲染出错误 
      >
      > ```js
      > {{ extend './common/layout.art' }}
      > 
      > {{ block 'main' }}
      > 	<p class='bg-danger error'>{{msg}}</p>
      > {{ /block }}
      > ```

      现在浏览器中直接刷新， 相对美观

   2. 用户看到这个结果后，需要用户3s之后就跳转到登陆页面。

      在`views/admin/error.art`中，使用javascript脚本，完成定时器. 放在文件末尾，粘贴以下代码

      ```js
      {{ block 'script' }}
      	<script	type="text/javascript">
      		setTimeout(function() {
      			location.href = '/admin/login';
      		}, 3000) // 3s之后跳转login
      	</script>
      {{ /block }}
      ```

      > 验证时，**先不着急刷新**，需要启用javascript代码：在浏览器的F12中，使用`ctrl+shift + P`， 输入`enable javascript`
      >
      > 现在再点刷新按钮，会发现自动跳转回登录页面

#### 查询用户信息

在`route/admin.js`的POST方法的/login路由中，获取用户信息
```js
 // 实现登录功能
 admin.post('/login', async (req, res)=> { //异步函数
     // 接收请求参数
     const {email, password} = req.body;

     if (email.trim().length == 0 || password.trim().length == 0) {
         // 客户端请求格式问题
         return res.status('401').render('admin/error', {msg: '邮件地址或密码错误'});
     }
     // 查询用户信息, 异步函数获取异步api的结果
     // 查询到了，user变量的值是对象类型(存储用户信息)。如果没有查询到用户，user变量为空
     let user = await User.findOne({ email }); // 邮箱地址只能查询到一个，所以使用findOne； find则查询多个;   参数：由于es6中的key与value相同时，则简写了{key}

     if (user) {

     } else {
         // 服务器未查询到用户
         return res.status('401').render('admin/error', {msg: '邮件地址或密码错误'});
     }
 });
```

> - 导入用户集合，在`const express = require('express');` 后方
>
>   ```js
>   // 导入用户集合构建函数
>   const { User } = require('../model/user')
>   ```
>
>   > 解构User对象

通过浏览器访问时，可以发现已经报错，并且跳转回登陆页面

现在用户失败的情况已经处理了， 接下来处理查询到用户的情况 ​									

#### 密码对比

在`route/admin.js`的POST方法的/login路由中，用户获取到了，就对比密码

```js

	if (user) {
		if ( password == user.password) {
			// 登录成功
            res.send('登录成功')
		} else {
			// 使用初始化用户：itheima@itcast.cn， 但是密码不给对，来验证
			return res.status('401').render('admin/error', {msg: '邮件地址或密码错误'});
		}
	} 
```

> 现在浏览器请求，可以发现用户存在时的失败和成功，成功时如图：
>
> ![image-20210913130457491](http://myapp.img.mykernel.cn/image-20210913130457491.png)



## 登录完善

[^478]:

### 待完善点 

| bug                                              | 缺点                                                         | 解决方案                                                     |
| ------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据库明文存储密码                               | navicat查询的结果 用户的密码就是12345，不安全。数据库被黑客侵入，密码是明文的，黑客很容易以用户的身份做不法的事情。![image-20210913130840510](http://myapp.img.mykernel.cn/image-20210913130840510.png) | 加密存储                                                     |
| 登录成功后，客户端再次访问，服务器认不得用户     |                                                              | cookie和session                                              |
| 现在没有登陆情况下，用户可以看到博客的管理页面。 |                                                              | 登陆拦截                                                     |
| 功能代码不放在app.js中                           |                                                              | 中间件放在博客根目录下的middleware目录中。<br/> route/admin.js 路由文件的中处理函数使用route/admin/xx.js专门放。 |

### bycrypt加密密码存储

[^479]:
[^480]:

单向加密+盐

异步api, 加密

安装bcrypt

```bash
npm install --save bcrypt --registry=http://r.npm.taobao.org/
```



切换blog目录中，测试bcrypt `blog/hash.js`

```js
const bcrypt = require('bcrypt');


async function run() {
	let salt = await bcrypt.genSalt(10); // 默认10位
	let pass = await bcrypt.hash('12345', salt);
	console.log(salt)
	console.log(pass)
}

run()
```

运行

```bash
$ node hash.js
$2b$10$U7j3SpMcjVEZeWywskv/gu
$2b$10$U7j3SpMcjVEZeWywskv/gu9F9SyUvOV3m9mE7HSYku2s96T5yqnda
```

向数据库插入用户， 编辑`model/user.js`

```js
// 在exports前
async function createUser() {
	let salt = await bcrypt.genSalt(10); // 默认10位
	let pass = await bcrypt.hash('12345', salt);

	const user = await User.create({
	username: 'itheima',
	email: 'itheima@itcast.cn',
	password: pass,
	role: 'admin',
	state: 0
	});
}

createUser();
```

> 注意需要在首行引入bcrypt依赖
>
> ```js
> const bcrypt = require('bcrypt');
> ```

由于我们的user.js文件已经在`route/admin.js`中引入，所以文件重载时，就会重新添加用户. 在添加前，先删除mongo中的users集合

![image-20210913135446643](http://myapp.img.mykernel.cn/image-20210913135446643.png)

> 现在的密码已经加密了

先注释`createUser();`

现在在route/admin.js 对比密码时，使用bcrypt方法对比

```js
	if (user) {
		// true成功
		// false 失败
		let isVaild = await bcrypt.compare(password, user.password)
		if ( isVaild ) {
			// 登录成功
			res.send('登录成功');
		} else {
			// 使用初始化用户：itheima@itcast.cn， 但是密码不给对，来验证
			return res.status('401').render('admin/error', {msg: '邮件地址或密码错误'});
		}
	} else {
		// 服务器未查询到用户
		return res.status('401').render('admin/error', {msg: '邮件地址或密码错误'});
	}
```

> - 在登录成功注释之上修改登录成功的对比逻辑。不是明文对比，而是使用bcrypt模块对比
>
> 注意需要在首行引入bcrypt依赖
>
> ```bash
> const bcrypt = require('bcrypt');
> ```

现在浏览器访问`localhost/admin/login`已经正常登陆



### 登录

#### 登录不成功验证

[^481]:

登录成功后，修改req对象的属性添加用户名，并在请求`/admin/user` 时，显示用户列表

编辑login路由

```js
	if (user) {
		// true成功
		// false 失败
		let isVaild = await bcrypt.compare(password, user.password)
		if ( isVaild ) {
			req.username = user.username; // 向req添加属性username, 存储查询的用户名。
			// 登录成功
			res.send('登录成功');
```

> 登录成功前，存储用户名

编辑user路由， 传递用户名给admin/user模板

```js
admin.get('/user', (req, res)=> {
	res.render('admin/user', {
		msg: req.username
	});
});
```

`views/admin/user.art`模板读取用户

```diff
    <div class="content">
    	<!-- 侧边栏 -->
        {{ include './common/aside.art' }}
        <!-- 侧边栏 -->
        <div class="main">
        	<!-- 分类标题 -->
            <div class="title">
+                <h4>用户 {{msg ? msg : '用户名不存在'}}</h4>
                <span>找到1个用户</span>
                <a href="user-edit.html" class="btn btn-primary new">新增用户</a>
            </div>
```

> msg就是前面传递的用户名，如果用户名存在就显示。不存在就显示不存在

现在登录，`http://localhost/admin/login`, 登录成功后，现在请求服务端的`http://localhost/admin/user`

![image-20210913140936538](http://myapp.img.mykernel.cn/image-20210913140936538.png)

为什么认不得用户呢，基于http(请求和响应)，请求和响应后会断开。服务端就不认得客户端。

#### cookie和session

[^482]:

需要建立客户端与服务端的关联关系。控制台：`application->cookies`

cookie: 服务器用来存储数据到客户端。

- 过期时间到达时，浏览器会删除cookie
- 浏览器关闭时会自动删除
- 会随着请求自动发给服务器端

session: 一个对象，存储在服务器的内存中。session_id是惟一识别。

如何复用cookie和session实现登录

![image-20210913142953693](http://myapp.img.mykernel.cn/image-20210913142953693.png)

#### 使用cookie和session实现登陆

[^483]:

`express-session`使用示例

```js
const session = require('express-session');
app.use(session({secret: 'secret key'}));
```

> 安装依赖
>
> ```bash
> $ npm install --save express-session
> ```
>
> 为req添加session属性，值是对象，会保存用户信息。存储数据时生成session_id. 然后会把session_id存储到客户端的cookie中，重复请求时，服务器从cookie获取用户信息。
>
> session() 方法传递的参数，存储密钥，密钥的值，是用来加密cookie信息的。接收到信息时，需要使用此密钥解密。



在`app.js`中，首行导入模块

```js
const session = require('express-session');
```

然后在其它的`app.use`旁边引入中间件处理所有请求

```bash
app.use(session({secret: 'secret key',
	saveUninitialized: false,  // 未登陆时，就不发cookie
	cookie: {
		maxAge: 24 * 60 * 60 * 1000 //cookie过期时间，用户登陆成功后，会给用户发cookie, 此cookie一直可以登陆。配置此选项时，用户cookie超过24h就需要重新登陆
	}
}));
```

现在用户登陆后，才可以看到cookie, 而且会显示是1天后过期 

![image-20210918130812288](http://myapp.img.mykernel.cn/image-20210918130812288.png)

现在在用户检验成功之后，就把用户名存储到session中, session方法会在内部自动生成session_id，并且把sessoin_id存储到用户的cookie中

```diff
	if (user) {
		// true成功
		// false 失败
		let isVaild = await bcrypt.compare(password, user.password)
		if ( isVaild ) {
+			req.session.username = user.username; // 将用户名存储到session对象中
			// 登录成功
			res.send('登录成功');
```

> 现在登陆成功后，将生成session, 以下通过F12查看session
>
> ![image-20210913151615147](http://myapp.img.mykernel.cn/image-20210913151615147.png)
>
> > connect.sid 是 express-session默认名
> >
> > 加密字符就是生成的惟一的session_id
>
> 后面服务器获取此session_id, 查询session中的此id, 就关联了用户

现在我们修改`/admin/user`路由，修改如下

```diff
admin.get('/user', (req, res)=> {
	res.render('admin/user', {
+		msg: req.session.username
	});
});
```

> 然后重新登录，之后在访问`localhost/admin/user`, 现在页面中就可以显示出`username`了
>
> ![image-20210913152516703](http://myapp.img.mykernel.cn/image-20210913152516703.png)

#### 登录成功后 

[^484]:

跳转到用户列表, express框架提供了`redirect`, 编辑验证成功的代码

```js
		if ( isVaild ) {
			req.session.username = user.username; // 将用户名存储到session对象中
			// 登录成功
			res.redirect('/admin/user');
		} else {
```

> 现在登录成功后，会自动跳转到用户列表页

需要将用户名显示到列表页的header中，header是公共区域，不能单独在用户列表页中header修改用户名，其他页面也需要显示这个。公共的数据，需要暴露到模板中。`app.locals`

编辑`admin.js`

```diff
	if (user) {
		// true成功
		// false 失败
		let isVaild = await bcrypt.compare(password, user.password)
		if ( isVaild ) {
			req.session.username = user.username; // 将用户名存储到session对象中
			// 登录成功
+			req.app.locals.userInfo = user;
			res.redirect('/admin/user');
		} else {
```

> req.app属性即`app.js`中创建的app对象

现在就不需要在用户列表页面，传递用户信息了，因为用户信息已经在全局的`app.locals`对象中

```js
admin.get('/user', (req, res)=> {
	res.render('admin/user');
});
```

现在在`admin/user.art`模板使用变量替换`admin`

```diff
        <!-- 用户信息 -->
        <div class="info">
            <div class="profile dropdown fr">
                <span class="btn dropdown-toggle" data-toggle="dropdown">
+					{{ userInfo.username }}
					<span class="caret"></span>
                </span>
```

并把之前的显示用户名修改为`                <h4>用户 {{ userInfo ? userInfo.username  : '用户名不存在'}}</h4>`

> 一旦我们修改了这个文件，nodemon重载内存数据会丢失，所以需要重新登陆。

现在有一个问题，不登陆的情况下，去请求/admin/user就会报错

![image-20210913164518828](http://myapp.img.mykernel.cn/image-20210913164518828.png)

所以修改代码

```js
{{ userInfo && userInfo.username }}
```



### 登陆拦截

[^486]:

当客户端给服务端发送请求时，先判断一下请求，除了登陆页面的其他url是`/admin/`开头，是登陆的，才OK。没有登陆，就重定向到登陆页面。

使用express的中间件, 编辑`app.js`, 在路由前粘贴以下代码. 即`app.use('/home', home);` 代码之上

```js
// 拦截请求，判断用户登录状态
app.use('/admin', (req, res, next) => {
	// 判断用户访问的是否登录页面
	//判断用户登录状态，是登录的就放行。不登录就重定向
	if (req.url != '/login' && ! req.session.username ) { // 非登陆页，未登陆
		res.redirect('/admin/login');
	} else {
		// 是登陆状态， 放行请求
		next();
	}

});
```

> 中间件是有顺序的，所以在路由之前

浏览器中F12清理cookie, 然后直接请求`http://localhost/admin/user`，可以发现跳转到登陆页了

现在登陆之后，会跳转到user页面，cookie生成了，再清理cookie, 刷新同样会跳转登陆页面。

### 代码优化

[^487]:

#### app.js

功能代码不应该放在此文件中, 比如`app.js`中的登陆拦截中间件，通常会在项目的目录下创建middleware目录放中间件函数

```bash
$ install blog/middleware -dv
$ touch middleware/loginGuard.js
```

`loginGuard.js`

```js
const guard = (req, res, next) => {
	// 判断用户访问的是否登录页面
	//判断用户登录状态，是登录的就放行。不登录就重定向
	if (req.url != '/login' && ! req.session.username ) { // 非登陆页，未登陆
		res.redirect('/admin/login');
	} else {
		// 是登陆状态， 放行请求
		next();
	}
};

module.exports = guard;
```

`app.js` 中的中间件引入此模块

```js
// 拦截请求，判断用户登录状态
app.use('/admin', require('./middleware/loginGuard'));
```

浏览器验证，参考[登陆拦截](#登陆拦截)

#### admin.js

所有的路由在一个文件中，将来很多路由，此文件相当庞大

真实的项目中，会把路由处理文件，放在一个单独的文件中，是一个路由列表。

1. 复制`admin.js`，login路径的处理函数，放在`/route/admin/admin/login.js`

    ```js
    const login = async (req, res)=> { //异步函数
        // 接收请求参数
        const {email, password} = req.body;
    
        if (email.trim().length == 0 || password.trim().length == 0) {
            // 客户端请求格式问题
            return res.status('401').render('admin/error', {msg: '邮件地址或密码错误'});
        }
        // 查询用户信息, 异步函数获取异步api的结果
        // 查询到了，user变量的值是对象类型(存储用户信息)。如果没有查询到用户，user变量为空
        let user = await User.findOne({ email }); // 邮箱地址只能查询到一个，所以使用findOne； find则查询多个;   参数：由于es6中的key与value相同时，则简写了{key}
    
        if (user) {
            // true成功
            // false 失败
            let isVaild = await bcrypt.compare(password, user.password)
            if ( isVaild ) {
                req.session.username = user.username; // 将用户名存储到session对象中
                // 登录成功
                req.app.locals.userInfo = user;
                res.redirect('/admin/user');
            } else {
                // 使用初始化用户：itheima@itcast.cn， 但是密码不给对，来验证
                return res.status('401').render('admin/error', {msg: '邮件地址或密码错误'});
            }
        } else {
            // 服务器未查询到用户
            return res.status('401').render('admin/error', {msg: '邮件地址或密码错误'});
        }
    }
    
    module.exports = login;
    ```

    > 当前代码使用了user集合，导入user. 加密模块
    >
    > ```js
    > // 导入用户集合构建函数
    > const { User } = require('../../model/user')
    > const bcrypt = require('bcrypt');
    > ```
    >
    > login.js中申明变量，又导出，可以简写为
    >
    > ```bash
    > module.exports = = async (req, res)=> { //异步函数
    > 	// 接收请求参数
    > 	const {email, password} = req.body;
    > 
    > 	if (email.trim().length == 0 || password.trim().length == 0) {
    > 		// 客户端请求格式问题
    > 		return res.status('401').render('admin/error', {msg: '邮件地址或密码错误'});
    > 	}
    > 	// 查询用户信息, 异步函数获取异步api的结果
    > 	// 查询到了，user变量的值是对象类型(存储用户信息)。如果没有查询到用户，user变量为空
    > 	let user = await User.findOne({ email }); // 邮箱地址只能查询到一个，所以使用findOne； find则查询多个;   参数：由于es6中的key与value相同时，则简写了{key}
    > 	
    > 	if (user) {
    > 		// true成功
    > 		// false 失败
    > 		let isVaild = await bcrypt.compare(password, user.password)
    > 		if ( isVaild ) {
    > 			req.session.username = user.username; // 将用户名存储到session对象中
    > 			// 登录成功
    > 			req.app.locals.userInfo = user;
    > 			res.redirect('/admin/user');
    > 		} else {
    > 			// 使用初始化用户：itheima@itcast.cn， 但是密码不给对，来验证
    > 			return res.status('401').render('admin/error', {msg: '邮件地址或密码错误'});
    > 		}
    > 	} else {
    > 		// 服务器未查询到用户
    > 		return res.status('401').render('admin/error', {msg: '邮件地址或密码错误'});
    > 	}
    > }
    > ```
    >
    > 

     然后修改`admin.js`

    ```js
    // 实现登录功能
    admin.post('/login', require('./admin/login'));
    ```

    现在浏览器验证登录功能

2. admin.js其它路由参数第1步，完成

   ```js
   get.login -> loginPage.js
   post.login -> login.js
   get./user  -> userPage.js
   get./logout -> logout.js
   ```

3. logout功能

   ```js
   admin.get('/logout', require('./admin/logout'));
   ```

   `route/admin/admin/logout.js`

   ```js
   module.exports = (req, res) => {
   	//删除session
   	req.session.destroy(function () {
   		// 删除cookie
   		res.clearCookie('connect.sid');
   
   		// 重定向到用户登录页
   		res.redirect('/admin/login');
   	})
   }
   ```

   编辑`views/admin/common/header.art`

   ```html
                       <li><a href="/admin/logout">退出登录</a></li>
   ```

   浏览器请求时，可以发现一次请求

   ```bash
   Connection: keep-alive
   Content-Length: 68
   Content-Type: text/html; charset=utf-8
   Date: Mon, 13 Sep 2021 09:22:06 GMT
   Keep-Alive: timeout=5
   Location: /admin/login
   Set-Cookie: connect.sid=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT
   Vary: Accept
   X-Powered-By: Express
   ```

   > 把浏览器的cookie设置为空

## 新增用户功能

[^488]:

客户端javascript验证忽略，生产中不可以忽略

1. 为新增用户按键添加链接
2. 添加链接对应的路由，在路由处理函数中渲染新增页面
3. 为新增用户表单指定请求地址、请求方式、为表单控件添加name属性，以便路由获取参数检验，添加用户
4. 添加用户的路由
5. 接受参数，验证格式，验证邮箱地址已经注册，需要告诉用户已经注册。没有注册就加密用户密码，添加用户，添加后重定向到列表页面

### 基础操作

此处可以参考3.3登录到3.2.3.2，完成。

- 由于路由登陆拦截了，所以我们每一次的操作都需要重新登录，先注释拦截

  ```diff
  // 拦截请求，判断用户登录状态
  +// app.use('/admin', require('./middleware/loginGuard'));
  
  
  // 为路由对象映射请求路径
  app.use('/home', home);
  app.use('/admin', admin);
  ```

- 先配置路由

  `route/admin/admin/userEditPage.js`

  ```js
  module.exports = (req, res)=> {
  	res.render('admin/user-edit')
  };
  ```

  `route/admin/admin.js`

  ```diff
  admin.get('/user-edit', require('./admin/userEditPage'));
  ```

  浏览器验证, OK

- 现在配置新建按钮的地址 `views/admin/user.art`

  ```diff
              <div class="title">
                  <h4>用户 {{ userInfo ? userInfo.username  : '用户名不存在'}}</h4>
                  <span>找到1个用户</span>
  +                <a href="/admin/user-edit" class="btn btn-primary new">新增用户</a>
              </div>
  ```

  验证点按钮可以跳转

- 表单配置：方法、地址、id(检验使用)、表单控件的name属性供检验、后端使用 `views/admin/user-edit.art`

  ```diff
  +            <form action="/admin/user-edit" method="POST" id="userEdit" class="form-container">
                  <div class="form-group">
                      <label>用户名</label>
  +                    <input name="username" type="text" class="form-control" placeholder="请输入用户名">
                  </div>
                  <div class="form-group">
                      <label>邮箱</label>
  +                    <input name="email" type="email" class="form-control" placeholder="请输入邮箱地址">
                  </div>
                  <div class="form-group">
                      <label>密码</label>
  +                    <input name="password" type="password" class="form-control" placeholder="请输入密码">
                  </div>
                  <div class="form-group">
                      <label>角色</label>
  +                    <select name="role" class="form-control">
  +                        <option value="normal">普通用户</option>
  +                        <option value="admin">超级管理员</option>
                      </select>
                  </div>
                  <div class="form-group">
                      <label>状态</label>
  +                    <select name="state" class="form-control">
  +                        <option value="0">启用</option>
  +                        <option value="1">禁用</option>
                      </select>
                  </div>
  ```

  > 首行是地址方法及id
  >
  > 以下是name属性

  然后加禁用默认的提交，验证获取的数据

  ```js
  {{ block 'script' }}
      <script type="text/javascript">
          $('#userEdit').on('submit', function() {
              var result = serializeToJson($(this));
              console.log(result);
              return false;
          });
      </script>
  {{ /block }}
  ```

  ![image-20210913174256074](http://myapp.img.mykernel.cn/image-20210913174256074.png)

  正常后，打开默认的自动提交

- 准备提交的路由

  `route/admin/admin/userEditPage.js`

  ```js
  module.exports = (req, res) => {
  	res.send(req.body)
  }
  ```

  `route/admin/admin.js`

  ```js
  admin.post('/user-edit', require('./admin/userEdit'));
  ```

  浏览器结果 `{"username":"123123","email":"heima@itcast.com","password":"123123","role":"normal","state":"0"}`


### 检验操作



#### joi官方文档示例

[^489]:

新增用户，字段比较多，手工验证代码写着不难，但是比较啰嗦也浪费时间。所以写操作验证使用第3方模块来验证。

第三方模块`Joi`, JavaScript大量规则可以验证javascript对象，因为请求参数就是req对象，所以就可以验证。

```js
const Joi = require('joi');

// 定义验证规则
const schema = {
    username: Joi.string().alphanum().min(3).max(30).required().error(new Error(`错误信息`)),
    password: Joi.string().regex(/^[a-zA-Z0-9]{3,30}$/),
    access_token: [Joi.string(), Joi.number()],
    birthyear: Joi.number().integer().min(1900).max(2013),
    email: Joi.string().email()
}

Joi.validate({username: 'abc', birthyear: 1994}, schema) // first arg: 待验证的对象。 second arg: 验证规则  异步函数使用，验证成功返回待验证的对象，失败就抛出异常。
```

> username属性，Joi.string(), 表示必须是字符串类型，属性存储了其它类型，验证将不能通过。 alphanum() 表示其值必须是字母或数字字符串，不能有`_, $`, min/max 最小/大长度。 required 必给属性，验证的对象没有此属性，则验证不通过。默认情况下不会加required，就是可选属性。error方法指定Error对象的错误信息
>
> password属性，字符串，必须匹配正则规则。
>
> access_token,  数组中有2个数据类型，表示其值要么是字符，要么是数字，如果是其它类型，验证将不能通过。
>
> birthyear, 数值，整数，最小和最大来指定范围。
>
> email: 字符串，email方法，值必须是邮件。
>
> 1. 首先给数据类型



接下来验证对象 `blog/joi.js`

> 官方文档: https://joi.dev/api/?v=12.1.0
>
> 视频中joi版本比较旧，所以需要安装指定版本的joi
>
> 1. 获取版本
>
>    ```bash
>    npm view joi versions
>    ```
>
> 2. 安装指定版本
>
>    ```bash
>    npm install <package>@<version>
>    ```
>
> 3. 安装模糊版本
>
>    ```bash
>    npm install <package>@~<version_prefix>
>    ```
>
>    

```js
// 引入模块
const Joi = require('joi');



// 定义对象的验证规则
const schema = {
	username: Joi.string().min(2).max(5)
}



async function run() {
	try { 
		// 验证对象
		await Joi.validate({username: 'ab'},schema);
	} catch (ex) {
		console.log(ex);
		return; // 阻止向下执行
	}
	console.log('验证通过')
}

run();
```

运行结果

```js
$ node joi.js
验证通过
```

如果只给`a`, 会出现大量的错误，但是需要简洁的，更新异常处理为

```js
	} catch (ex) {
		console.log(ex.message);
```

就会报错 `'"username" length must be at least 2 characters long',`要显示中文，对用户不友好

```bash
$ node joi.js
child "username" fails because ["username" length must be at least 2 characters
long]
```

现在更新报错输出

```js
	username: Joi.string().min(2).max(5).error(new Error('username属性没有通过验证'))
```

> 再执行
>
> ```bash
> $ node joi.js
> username属性没有通过验证
> ```

现在不传递username时， 验证是通过的。

```diff
	try { 
		// 验证对象
+		await Joi.validate({},schema);
	} catch (ex) {
```

> ```bash
> $ node joi.js
> 验证通过
> ```

现在要求username是必给的

```diff
const schema = {
+	username: Joi.string().min(2).max(5).required().error(new Error('username属性没有通过验证'))
}
```

> $ node joi.js
> username属性没有通过验证



现在验证新字段

```diff
// 定义对象的验证规则
const schema = {
	username: Joi.string().min(2).max(5).required().error(new Error('username属性没有通过验证')),
+	birth: Joi.number().min(1900).max(2020).error(new Error('birth属性没有通过验证'))
}



async function run() {
	try { 
		// 验证对象
+		await Joi.validate({username: 'ab', birth: 1800},schema);
	} catch (ex) {
```

> $ node joi.js
> birth属性没有通过验证

#### 为客户端传递的参数添加验证

[^490]:

`route/admin/userEdit.js` 文件中粘贴以下代码

```js
const Joi = require('joi');

module.exports = async (req, res) => {
	
	// 规则 
	const schema = {
		username: Joi.string().min(2).max(12).required().error(new Error('username不符合验证规则')),
		email:    Joi.string().email().required().error(new Error('email格式不符合要求')),
		password: Joi.string().regex(/^[a-zA-Z0-9]{3,30}$/).required().error(new Error('password格式不符合要求')),
		role:     Joi.string().valid('normal', 'admin').required().error(new Error('role值非法')), // valid 传递合法的值
		state:    Joi.number().valid(0, 1).required().error(new Error('state值非法')) 
	}

	try {
		// 验证
		await Joi.validate(req.body, schema)
	} catch(e) {
		console.log(e.message);
		return ; //不向下执行
	}


	res.send(req.body)
}
```

> 规则，到底写什么？参考页面`http://localhost/admin/user-edit`
>
> 提交后的`{"username":"123123","email":"123@qq.com","password":"123","role":"normal","state":"0"}`
>
> 在`model/user.js`也定义了
>
> ```js
> const UserSchema = new mongoose.Schema({
> 	username: {
> 		type: String,
> 		required: true,
> 		minlength: 4,
> 		maxlength: 11
> 	},
> 	email: {
> 		type: String,
> 		required: true,
> 		unique: true
> 	},
> 	password: {
> 		type: String,
> 		required: true
> 	},
> 	role: { // 超级管理员：admin， 普通用户：normal. 
> 		type: String,
> 		required: true
> 	},
> 	state: {                      
> 		type: Number,
> 		default: 0 // 默认0是启用。1则是禁用
> 	}
> });
> ```

现在基本可以完成验证，但是这个catch的错误信息应该显示在这里

![image-20210914102242514](http://myapp.img.mykernel.cn/image-20210914102242514.png)

当用户点了提交，就会验证，提交，POST请求后端接口，接口中验证失败就重定向到编辑页面，并把错误放在地址栏中

```js
	} catch(e) {
		// res.redirect('/admin/user-edit?message=' + e.message);
		res.redirect(`/admin/user-edit?message=${e.message}`);
		return ; 
	}
```

> 现在验证错误，什么都不填写的状态如下。
>
> ![image-20210914102749289](http://myapp.img.mykernel.cn/image-20210914102749289.png)
>
> 直接点提交后的结果
>
> ![image-20210914102811581](http://myapp.img.mykernel.cn/image-20210914102811581.png)

现在在`route/admin/userEditPage.js`中 `res.render('admin/user-edit')` 之前获取地址栏的参数

```js
module.exports = (req, res)=> {
	const { message } = req.query;
	res.render('admin/user-edit', {
		message: message
	})
};
```

现在模块文件，添加错误 `views/admin/user-edit.art`

```diff
        <div class="main">
            <!-- 分类标题 -->
            <div class="title">
                <h4>5b9a716cb2d2bf17706bcc0a</h4>
+                <p class="tips">{{ message }}</p>
            </div>
```

> 现在请求就会发现，默认是空，一旦我们空白提交就会提示在页面中间

#### 验证客户端的邮箱

`route/admin/userEdit.js`文件的`res.send(req.body)`替换，粘贴以下代码。因为上面已经获取异常了，表示下面的代码一定是验证OK之后的操作

```js
	// 根据邮箱地址查询用户是否存在, findOne, 邮箱是惟一返回是对象。 没有找到就是空
	let user = await User.findOne({ email: req.body.email })	

	res.send(user)
```

> 文件首行引入User
>
> ```js
> const { User } = require('../../model/user');
> ```
>
> 浏览器新增用户，`itheima@itcast.cn` 使用这个邮箱，其他随便填写， 显示出了这个对象，是注册过的
>
> ![image-20210914111249779](http://myapp.img.mykernel.cn/image-20210914111249779.png)
>
> 换个邮箱的结果，浏览器是空白

现在把`res.send(user)` 替换成以下代码，进行用户判断进行处理，占用就提示，未占用就加密密码

```js
	if (user) {
		// 邮件被占用
		return res.redirect(`/admin/user-edit?message=邮箱地址已经被占用`); // 不return时，后面的代码会继续执行
	} else {
		// 邮件未占用
		// 密码加密处理
		let salt = await bcrypt.genSalt(10); // 默认10位
		let pass = await bcrypt.hash(req.body.password, salt);
		// 替换密码
		req.body.password = pass;
		// 写数据库
		res.send(req.body)
	}
```

> 浏览器验证![image-20210914111940691](http://myapp.img.mykernel.cn/image-20210914111940691.png)

替换`res.send(req.body)`为以下代码，即将用户信息写入数据库，调用create方法，现在重定向到用户列表页面

```js
		// 写数据库
		await User.create(req.body);
		return res.redirect('/admin/user');
```

> 创建用户，`mongoose.model` 自带create方法，接用户属性即可
>
> 浏览器访问，已经OK，navicat查询已经存在用户
>
> ![image-20210914113549947](http://myapp.img.mykernel.cn/image-20210914113549947.png)

最终添加用户的代码

```js
const { User } = require('../../model/user');

const Joi = require('joi');


const bcrypt = require('bcrypt');

module.exports = async (req, res) => {
	
	// 规则 
	const schema = {
		username: Joi.string().min(2).max(12).required().error(new Error('username不符合验证规则')),
		email:    Joi.string().email().required().error(new Error('email格式不符合要求')),
		password: Joi.string().regex(/^[a-zA-Z0-9]{3,30}$/).required().error(new Error('password格式不符合要求')),
		role:     Joi.string().valid('normal', 'admin').required().error(new Error('role值非法')), // valid 传递合法的值
		state:    Joi.number().valid(0, 1).required().error(new Error('state值非法')) 
	}

	try {
		// 验证
		await Joi.validate(req.body, schema)
	} catch(e) {
		// res.redirect('/admin/user-edit?message=' + e.message);
		res.redirect(`/admin/user-edit?message=${e.message}`);
		return ; //不向下执行
	}

	// 根据邮箱地址查询用户是否存在, findOne, 邮箱是惟一返回是对象。 没有找到就是空
	let user = await User.findOne({ email: req.body.email })	

	if (user) {
		// 邮件被占用
		return res.redirect(`/admin/user-edit?message=邮箱地址已经被占用`); // 不return时，后面的代码会继续执行
	} else {
		// 邮件未占用
		// 密码加密处理
		let salt = await bcrypt.genSalt(10); // 默认10位
		let pass = await bcrypt.hash(req.body.password, salt);
		// 替换密码
		req.body.password = pass;
		// 写数据库
		await User.create(req.body);
		return res.redirect('/admin/user');
	}
}
```

虽然已经添加了用户，但是代码需要优化。不能将所有的代码放在路由函数中

### 优化代码 [^492]

#### 概览

| 优化代码                                                     | 优势                                      |
| ------------------------------------------------------------ | ----------------------------------------- |
| 数据相关的代码放在model文件中                                | 其他地方也需要检验用户，用户信息的修改    |
| 错误处理：检验失败时，用户已经存在时。都重定向了，代码重复了 | express提供错误处理中间件，统一处理错误。 |
|                                                              |                                           |



#### 数据检验代码

数据相关的代码放在model文件中, 抽取出来的好处，其他地方也需要检验用户。用户信息的修改

`model/user.js` 中替换`module.exports `，粘贴以下代码

```js

// 验证用户信息
const validateUser = user => {
	const schema = {
		username: Joi.string().min(2).max(12).required().error(new Error('username不符合验证规则')),
		email:    Joi.string().email().required().error(new Error('email格式不符合要求')),
		password: Joi.string().regex(/^[a-zA-Z0-9]{3,30}$/).required().error(new Error('password格式不符合要求')),
		role:     Joi.string().valid('normal', 'admin').required().error(new Error('role值非法')), // valid 传递合法的值
		state:    Joi.number().valid(0, 1).required().error(new Error('state值非法')) 
	}
	// 验证
	return Joi.validate(user, schema)
}

module.exports = { // 可能以后还有其他导入，所以导出对象。user只是键 key == value, 可以简写为 { key } 
	User,
	validateUser
}

```

> 需要行首导入`const Joi = require('joi');`

把`route/admin/userEdit.js` 修改为以下代码

```js
module.exports = async (req, res) => {

	try {
		await validateUser(req.body)
	} catch(e) {
		// res.redirect('/admin/user-edit?message=' + e.message);
		res.redirect(`/admin/user-edit?message=${e.message}`);
		return ; //不向下执行
	}
    
    ...
```

> 导入`validateUser`
>
> ```js
> const { User, validateUser } = require('../../model/user');
> ```
>
> 去掉Joi导入
>
> await 接validateUser， 原因是他return 了一个promise对象，就可以await.

现在浏览器验证，验证功能是否正常，什么都不填的情况下，代码好使

#### 错误处理

处理第1个检验失败的异常

`route/admin/userEdit.js`

```js
	try {
		await validateUser(req.body)
	} catch(e) {
		// res.redirect('/admin/user-edit?message=' + e.message);
		// res.redirect(`/admin/user-edit?message=${e.message}`);
		// return ; //不向下执行
		return next(JSON.stringify({path: '/admin/user-edit', message: e.message})); // next方法也需要停止执行。 默认只能接一个字符串参数，我们需要传递2个参数，所以存储对象，需要将对象转换成字符串。 JSON.stringify() 可以把对象转换成字符串
	}
```

`app.js`中，在路由代码的最后面, 即`app.use('/admin', admin);` 之后

```js
app.use((err, req, res, next) => {
	// 字符串转换对象
	const result = JSON.parse(err)
	res.redirect(`${result.path}?message=${result.message}`); // 更灵活，地址和消息不能写死。
})
```

浏览器检验，不填写表单，点提交。正常



处理第2个错误 

`route/admin/userEdit.js`

```js
	// 根据邮箱地址查询用户是否存在, findOne, 邮箱是惟一返回是对象。 没有找到就是空
	let user = await User.findOne({ email: req.body.email })	

	if (user) {
		// 邮件被占用
		// return res.redirect(`/admin/user-edit?message=邮箱地址已经被占用`); // 不return时，后面的代码会继续执行
		return next(JSON.stringify({path: '/admin/user-edit', message: '邮箱地址已经被占用'}))
	} else {
```

浏览器验证，使用之前已经使用的邮箱看看



## 用户信息展示在页面中 [^493]

1. 访问列表页面时，路由中查询，渲染用户列表页面模板。
2. 文件列表的分布功能

### 基础操作

路由`http://localhost/admin/user`

`route/admin.js`

```js
admin.get('/user', require('./admin/userPage'));
```

`route/admin/userPage.js`

```js
module.exports = (req, res)=> {
	res.render('admin/user');
}
```

### 查用户，渲染

引入用户集合，来查用户 `route/admin/userPage.js`

```js
const { User } = require('../../model/user');
```

替换导出函数

```js
module.exports = async (req, res)=> {
	let users = await User.find({})
	res.send(users);
	// res.render('admin/user', {
	// 	users: users
	// });
}
```

> 现在访问页面
>
> ![image-20210914121022529](http://myapp.img.mykernel.cn/image-20210914121022529.png)
>
> 可以发现这1托代码不好查看，使用插件格式化代码`json formatter.crx`
>
> 

接下来需要将数据展示在页面中

```js
const { User } = require('../../model/user');

module.exports = async (req, res)=> {
	let users = await User.find({})
	// res.send(users);
	res.render('admin/user', {
		users: users
	});
}
```

修改模板`views/admin/user.art`

1. 找到表格，`<thead><tr><th></th>....</tr></thead><tbody><tr><td></td>....</tr>....</tbody>`

   ```html
               <table class="table table-striped table-bordered table-hover custom-table">
                   <thead>
                       <tr>
                           <th>ID</th>
                           <th>用户名</th>
                           <th>邮箱</th>
                           <th>角色</th>
                           <th>状态</th>
                           <th>操作</th>
                       </tr>
                   </thead>
                   <tbody>
                       <tr>
                           <td>5b9a716cb2d2bf17706bcc0a</td>
                           <td>wangjian</td>
                           <td>wjb19891223@163.com</td>
                           <td>超级管理员</td>
                           <td>正常</td>
                           <td>
                               <a href="user-edit.html" class="glyphicon glyphicon-edit"></a>
                               <i class="glyphicon glyphicon-remove" data-toggle="modal" data-target=".confirm-modal"></i>
                           </td>
                       </tr>
                      ....
                   </tbody>
               </table>
   ```

2. 数据库中有多少个用户，这里就有多个用户，所以应该采用循环

   ```js
               <table class="table table-striped table-bordered table-hover custom-table">
                   <thead>
                       <tr>
                           <th>ID</th>
                           <th>用户名</th>
                           <th>邮箱</th>
                           <th>角色</th>
                           <th>状态</th>
                           <th>操作</th>
                       </tr>
                   </thead>
                   <tbody>
                       {{ each users}}
                       <tr>
                           <td>{{ $value._id }}</td>
                           <td>{{ $value.username }}</td>
                           <td>{{ $value.email }}</td>
                           <td>{{ $value.role }}</td>
                           <td>{{ $value.state }} </td>
                           <td>
                               <a href="user-edit.html" class="glyphicon glyphicon-edit"></a>
                               <i class="glyphicon glyphicon-remove" data-toggle="modal" data-target=".confirm-modal"></i>
                           </td>
                       </tr>
                       {{ /each }}
                   </tbody>
               </table>
   ```

   > 下面的字段名，就是查询的字段。并且下面的顺序要和上面的tr一致
   >
   > 刷新浏览器`http://localhost/admin/user`
   >
   > ![image-20210914123503511](http://myapp.img.mykernel.cn/image-20210914123503511.png)

3. 应该显示中文

   ```html
                           <td>{{ $value.role == "admin" ? "超级管理员" : '普通用户' }}</td>
                           <td>{{ $value.state == 0 ? '启用' : '禁用' }} </td>
   ```

4. id号有引号，由于数据库是object类型

   ```html
                           <td>{{@$value._id}}</td>
   ```

   > 原文输出



### 数据分页 [^494]

#### 不分页的劣势

数据非常多时，分批次显示。

现在批量生成20条数据, 更新`model/user.js`

```js
async function createUser(username) {
	let salt = await bcrypt.genSalt(10); // 默认10位
	let pass = await bcrypt.hash('12345', salt);

	const user = await User.create({
	username: username,
	email: `${username}@itcast.cn`,
	password: pass,
	role: 'normal',
	state: 0
	});
	return user;
}

names = ["shijin", "zhuwu", "chengda", "yangchun", "luzhishen", "lizhong", "zhoutong", "lingchong", "chaijin", "zhugui", "luqian", "songwan", "yangzhi", "suochao", "leiheng", "liutang",
"wuyong", "ruanxiaoer", "runxiaowu", "ruanxiaoqi", "gongsunsheng", "baisheng", "baisheng", "chaozheng", "songjiang", "songqing", "wusong", "zhangqing", "sunerniang", "shieng",
"kongming", "kongliang", "yanshun", "wangying"]

for (var i=0; i<names.length; i++) {
	createUser(names[i])
}  

```

> 一旦保存，会重载app.js, 就立即创建出所有用户, 然后注释以上代码
>
> ![image-20210914130408901](http://myapp.img.mykernel.cn/image-20210914130408901.png)
>
> 现在浏览器访问
>
> 

如果一次性展示所有数据，数据库查询时间长，用户等待时间也比较长，通常数据比较多的情况下，分页展示数据。

#### 分页核心要素

1. 当前页：当前看的页码，客户端产生，客户端get把页码参数传递给服务器

2. 总页数：根据总页数判断当前页是否是最后一页，决定下一页的按钮是否显示。总页数计算的。

   | 总数据条 | 每页显示条 | 总页数 |
   | -------- | ---------- | ------ |
   | 50       | 5          | 10     |
   | 52       | 5          | 11     |

   > 有余数，结果向上取整。
   >
   > 50/5=10
   >
   > 52/5=10.X -> 11 Math.ceil()

3. 分页功能需要2个方法

   - limit(2)限制查询数量，传入每页显示的数据量

   - skip(1) 跳过多少条数据，传入显示数据的开始的位置， 查询第1页就是0，第2页就是从10开始，第3页就是20开始。

     客户端传递来的是当前页，所以需要将当前页转换成开始的位置

     ```js
     // 查询第2页，从10开始
     （2-1)*10
     //查询第3页，从20开始
     (3-1)*10
     
     (当前页-1)*每页数量
     ```

测试从用户列表页的路由获取page参数

```js
	//接收客户端传递过来的当前页参数         ?page=x&size=x
	let page = req.query.page; 
	res.send(page)

	return;
```



![image-20210914125013374](http://myapp.img.mykernel.cn/image-20210914125013374.png)



接下来要计算总页数

```js
	//接收客户端传递过来的当前页参数         ?page=x&size=x
	let page = req.query.page; 

	// 每页10条
	let pagesize = 10;

	// 查询用户数据总数
	let count = await User.countDocuments({})

	res.send('用户的总数是' + count);

	return;
```

![image-20210914130528852](http://myapp.img.mykernel.cn/image-20210914130528852.png)

现在计算总页数

```js
module.exports = async (req, res)=> {
	//接收客户端传递过来的当前页参数         ?page=x&size=x
	let page = req.query.page; 

	// 每页10条
	let pagesize = 10;

	// 查询用户数据总数
	let count = await User.countDocuments({})

	// 计算总页数
	let total = Math.ceil(count / pagesize)

	res.send(`总页数${total}`);
	return ;
	
    
    
    
	let users = await User.find({})
	// res.send(users);
	res.render('admin/user', {
		users: users
	});
}
```

> 现在浏览器将显示总页数为4
>
> 总34 / 10 = 3, 余4， 向上取整 就是4页



所以分页的结果

```diff
const { User } = require('../../model/user');

module.exports = async (req, res)=> {
	//接收客户端传递过来的当前页参数         ?page=x&size=x
	let page = req.query.page; 

	// 每页10条
	let pagesize = 10;

	// 查询用户数据总数
	let count = await User.countDocuments({})

	// 计算总页数
	let total = Math.ceil(count / pagesize)

	// 当前页码对应的起始位置
+	let start = (page-1)*pagesize
	
	// 就是指定页指定数量的用户数量
+	let users = await User.find({}).limit(pagesize).skip(start)

	// res.send(users);
	res.render('admin/user', {
		users: users
	});
}
```



用户不传递页码时，默认第1页

```js
let page = req.query.page || 1; 
```

现在浏览器不会显示所有数据，仅仅有10条数据

![image-20210914132417007](http://myapp.img.mykernel.cn/image-20210914132417007.png)

现在地址栏，将页码为`http://localhost/admin/user?page=1` 不变

`http://localhost/admin/user?page=4` 仅会显示最后几行

![image-20210914132515392](http://myapp.img.mykernel.cn/image-20210914132515392.png)

#### 生成分页器 [^496]

用户点按钮来分页， 在`route/admin/userPage.js`中， 渲染模板的同时，把分页数据给模板, 当前、一共

```js
	// res.send(users);
	res.render('admin/user', {
		users: users,
		page: page,
		total: total
	});
}
```

在`views/admin/user.art`模板中，找到分页器

```html
            <ul class="pagination">
                <li>
                    <a href="#">
			        <span>&laquo;</span>
			      </a>
                </li>
                <li><a href="#">1</a></li>
                <li><a href="#">2</a></li>
                <li><a href="#">3</a></li>
                <li><a href="#">4</a></li>
                <li><a href="#">5</a></li>
                <li>
                    <a href="#">
			        <span>&raquo;</span>
			      </a>
                </li>
            </ul>
            <!-- /分页 -->
```

> 中间的href由总页数生成，可以使用原始语法生成
>
> ```diff
>             <!-- 分页 -->
>             <ul class="pagination">
>                 <li>
>                     <a href="#">
> 			        <span>&laquo;</span>
> 			      </a>
>                 </li>
> 
> +                <% for (var i=1; i<=total; i++) { %>
>                 
> +                <li><a href="#">{{i}}</a></li>
> 
> +                <% } %>
> 
>                 <li>
>                     <a href="#">
> 			        <span>&raquo;</span>
> 			      </a>
>                 </li>
>             </ul>
>             <!-- /分页 -->
> ```
>
> > 现在页面将显示正常的页码![image-20210914133515621](http://myapp.img.mykernel.cn/image-20210914133515621.png)
>
> 现在指定页码, 使用原始语法引用变量
>
> ```js
> <li><a href="/admin/user?page=<%=i %>">{{i}}</a></li>
> ```
>
> > 注意：page后面给的变量也可以使用 `{{i}}`, 原始一定是 `<%=变量 %>`, =表示输出的意思
> >
> > 现在浏览器刷新后，鼠标放在页码上，左下角的页码就正常了
>
> 第1个就是前1页， 最后就后1页，由当前页决定
>
> ```js
>                 <li>
>                     <a href="/admin/user?page=<%=page-1%>">
> 			        <span>&laquo;</span>
> 			      </a>
>                 </li>
> ```
>
> ```js
>                 <li>
>                     <a href="/admin/user?page=<%=page-0+1%>">
> 			        <span>&raquo;</span>
> 			      </a>
>                 </li>
> ```
>
> > `-0`的目的，就是隐式类型转换。`+`号不会转换
>
> 现在正常后，在第4页，点下一页时，就会打开第5页，就空白了，所以需要判断当前页是总页数时，就隐藏下一页。
>
> ```js
>                 <% if (page != total) { %>
>                 <li>
>                     <a href="/admin/user?page=<%=page-0+1%>">
> 			        <span>&raquo;</span>
> 			      </a>
>                 </li>
> 
>                 <% } %>
> ```
>
> > 控制一个元素的隐藏显示是display属性, 修改为如下
> >
> > ```js
> >                 <li style="display: <%= page-0+1 >= total ? 'none' : 'block;' %>">
> >                     <a href="/admin/user?page=<%=page-0+1%>">
> > 			        <span>&raquo;</span>
> > 			      </a>
> >                 </li>
> > ```
> >
> > > `display: block` 可以显示。
> > >
> > > `display: inline` 也可以显示， 就不会破坏原有样式
>
> 现在把当前页为1时，就隐藏前1页
>
> ```js
>                 <% if (page != 1) { %>
>                 <li>
>                     <a href="/admin/user?page=<%=page-1%>">
> 			        <span>&laquo;</span>
> 			      </a>
>                 </li>
>                 <% } %>
> ```
>
> > 控制元素显示
> >
> > ```js
> >                 <li style="display: <%= page-1 < 1 ? 'none' : 'inline' %>">
> >                     <a href="/admin/user?page=<%=page-1%>">
> > 			        <span>&laquo;</span>
> > 			      </a>
> >                 </li>
> > ```
> >
> > 

最终效果

```js
            <!-- 分页 -->
            <ul class="pagination">
                <li style="display: <%= page-1 < 1 ? 'none' : 'inline' %>">
                    <a href="/admin/user?page=<%=page-1%>">
			        <span>&laquo;</span>
			      </a>
                </li>


                <% for (var i = 1; i <= total; i++) { %>
                
                <li><a href="/admin/user?page=<%=i %>">{{i}}</a></li>

                <% } %>

                <li style="display: <%= page-0+1 > total ? 'none' : 'inline' %>">
                    <a href="/admin/user?page=<%=page-0+1%>">
			        <span>&raquo;</span>
			      </a>
                </li>
            </ul>
            <!-- /分页 -->
```



## 用户信息修改功能 [^504]

1. 点击用户后面的修改按钮时，跳转到修改页面。
2. 修改和添加同一个应用，跳转后区分添加和修改。如果修改操作，将修改的用户信息，从数据库查询出来，并展示，修改后提交表单推送给服务器。
3. 修改操作，修改页面上方，显示用户id, 添加用户时，此id不需要显示


### 基础操作

编辑`views/admin/user.art`

```diff
                <tbody>
                    {{ each users}}
                    <tr>
                        <td>{{@$value._id}}</td>
                        <td>{{ $value.username }}</td>
                        <td>{{ $value.email }}</td>
                        <td>{{ $value.role == "admin" ? "超级管理员" : '普通用户' }}</td>
                        <td>{{ $value.state == 0 ? '启用' : '禁用' }} </td>
                        <td>
+                            <a href="/admin/user-edit?id={{@ $value._id }}" class="glyphicon glyphicon-edit"></a>
                            <i class="glyphicon glyphicon-remove" data-toggle="modal" data-target=".confirm-modal"></i>
                        </td>
                    </tr>
```

> 路由指向编辑页面

现在浏览器只要新增就不会有查询参数，修改就一定有，这样 就区分了

### 展示修改的用户

#### 区分添加和修改用户

展示页面`route/admin/userEditPage.js`

 导入User

获取查询参数id

存在id就查询用户，渲染。不存在id时，就添加操作

```js
const { User } = require('../../model/user');


module.exports = async (req, res)=> {
	// 获取地址栏的id
	const { message, id } = req.query;

	// 如果传递了id, 说明是修改操作
	if (id) {
		// 修改操作
		let user = await User.findOne({_id: id});
		res.render('admin/user-edit', {
			message: message,
			user: user
		});

	}  else {
		// 添加操作
		res.render('admin/user-edit', {
			message: message
		});
	}

};
```

> await异步操作

2. 模板修改`views/admin/user-edit.art`

```diff
        <div class="main">
            <!-- 分类标题 -->
            <div class="title">
                <h4>{{@ user && user._id || ""}}</h4>
                <p class="tips">{{ message }}</p>
            </div>
            <!-- /分类标题 -->
            <form action="/admin/user-edit" method="POST" id="userEdit" class="form-container">
                <div class="form-group">
                    <label>用户名</label>
+                    <input name="username" type="text" class="form-control" placeholder="请输入用户名" value="{{user && user.username}}">
```

> value就是默认值 `{{user && user.username}}` 而不是{{user.username}}避免用户在添加时没有传递user，而报错
>
> 分别访问`http://localhost/admin/user-edit?id=613ee7516cdcedadcaefee54`
>
> `http://localhost/admin/user-edit`

3. 参考第2步，完成其他表单控件的默认值充足

   ```diff
               <form action="/admin/user-edit" method="POST" id="userEdit" class="form-container">
                   <div class="form-group">
                       <label>用户名</label>
                       <input name="username" type="text" class="form-control" placeholder="请输入用户名" value="{{user && user.username}}">
                   </div>
                   <div class="form-group">
                       <label>邮箱</label>
   +                    <input name="email" type="email" class="form-control" placeholder="请输入邮箱地址" value="{{user && user.email}}">
                   </div>
                   <div class="form-group">
                       <label>密码</label>
                       <input name="password" type="password" class="form-control" placeholder="请输入密码">
                   </div>
                   <div class="form-group">
                       <label>角色</label>
                       <select name="role" class="form-control">
   +                        <option value="normal" {{ user && user.role == "normal" ? 'selected' : '' }} >普通用户</option>
   +                        <option value="admin" {{ user && user.role == "admin" ? 'selected' : '' }} >超级管理员</option>
                       </select>
                   </div>
                   <div class="form-group">
                       <label>状态</label>
                       <select name="state" class="form-control">
   +                        <option value="0" {{ user && user.state == "0" ? 'selected' : '' }} >启用</option>
   +                        <option value="1" {{ user && user.state == "1" ? 'selected' : '' }}>禁用</option>
                       </select>
                   </div>
                   <div class="buttons">
                       <input type="submit" class="btn btn-primary">
                   </div>
               </form>
   ```

   > select这种，只需要option有selected属性就会选中
   >
   > password先忽略

   现在浏览器访问，普通用户和超级管理员是不同的选择

   

#### 修改表单中的密码

修改用户信息时，不允许修改密码，要修改密码，需要单独的地方做修改密码。

- 页面中隐藏密码
- 依然让用户输入密码，用户输入的密码正确，才让用户修改。如果不正确就不让他修改。



#### 表单提交的地址

表单的提交地址，需要修改，添加用户和修改用户是2个地址。 `route/admin/userEditPage.js`

```diff
const { User } = require('../../model/user');


module.exports = async (req, res)=> {
	// 获取地址栏的id
	const { message, id } = req.query;

	// 如果传递了id, 说明是修改操作
	if (id) {
		// 修改操作
		let user = await User.findOne({_id: id});
		res.render('admin/user-edit', {
			message: message,
			user: user,
+			link: '/admin/user-modify'
		});

	}  else {
		// 添加操作
		res.render('admin/user-edit', {
			message: message
+			link: '/admin/user-edit'
		});
	}
};
```

> 这样模板中引用link时，添加就是走user-edit, 修改就走user-modify `views/admin/user-edit.art`
>
> ```html
>   <form action="{{link}}" method="POST" id="userEdit" class="form-container">
> ```

#### 按钮文字

添加就添加，修改就修改 `route/admin/userEditPage.js`

```diff
	if (id) {
		// 修改操作
		let user = await User.findOne({_id: id});
		res.render('admin/user-edit', {
			message: message,
			user: user,
			link: '/admin/user-modify',
+			button: "修改"
		});

	}  else {
		// 添加操作
		res.render('admin/user-edit', {
			message: message
			link: '/admin/user-edit',
+			button: "添加"
		});
	}
```

> 编辑 `views/admin/user-edit.art`
>
> ```diff
>                 <div class="buttons">
> +                    <input type="submit" class="btn btn-primary" value="{{button}}">
>                 </div>
>             </form
> ```

#### id显示

编辑 `views/admin/user-edit.art`

```diff
        <!-- 侧边栏 -->
        <div class="main">
            <!-- 分类标题 -->
            <div class="title">
+                <h4 style="display: {{ button == '修改' ? 'block' : 'none'}}" >{{@ user && user._id}}</h4>
                <p class="tips">{{ message }}</p>
            </div>
```

### 用户信息修改

#### 步骤

1. 用户点了修改，就提交到实现修改功能的地址上
2. 提交修改用户的id
3. 建立用户路由
4. 接收参数，获取用户密码
5. id查询出用户, 比对密码，失败，报错，不修改。正常时，才修改

#### 密码比对失败时的处理

路由， 需要传递用户id, 才可以知道修改哪个用户  `route/admin/userEditPage.js`

```diff
const { User } = require('../../model/user');


module.exports = async (req, res)=> {
	// 获取地址栏的id
	const { message, id } = req.query;

	// 如果传递了id, 说明是修改操作
	if (id) {
		// 修改操作
		let user = await User.findOne({_id: id});
		res.render('admin/user-edit', {
			message: message,
			user: user,
+			link: `/admin/user-modify?id=${id}`,
			button: "修改"
		});

	}  else {
		// 添加操作
		res.render('admin/user-edit', {
			message: message,
			link: '/admin/user-edit',
			button: "添加"
		});
	}
};
```

添加路由 `route/admin.js`

```js
admin.post('/user-modify', require('./admin/userModify'));
```

对应的文件

```js
let { User, validateUser } = require('../../model/user');

module.exports = async (req, res, next) => {
	let { id } = req.query;

	
	// try {
	// 	await validateUser(req.body)
	// } catch(e) {
	// 	// 验证失败
	// 	return next(JSON.stringify({path: `/admin/user-edit`, message: e.message}));
	// }
	// 检验过程中的message怎么搞

	let user = await User.findOne({_id: id})

	if (user) {
		// true成功
		// false 失败
		let isVaild = await bcrypt.compare(req.body.password, user.password)
		if ( isVaild ) {

		} else {
			// 失败时也需要 return next, 但是app.js中默认message在第1个
		}
	} else {

	}
}
```



现在`userModify.js`

```js
let { User, validateUser } = require('../../model/user');
const bcrypt = require('bcrypt');

module.exports = async (req, res, next) => {
	let { id } = req.query;

	
	try {
		await validateUser(req.body)
	} catch(e) {
		// 验证失败
		return next(JSON.stringify({path: `/admin/user-edit`, message: e.message, id: id}));
	}

	let user = await User.findOne({_id: id})

	if (user) {
		// true成功
		// false 失败
		let isVaild = await bcrypt.compare(req.body.password, user.password)
		if ( isVaild ) {
			res.send('密码对比成功')
		} else {
			// res.send('密码对比失败')
			return next(JSON.stringify({path: `/admin/user-edit`, message: '密码比对失败不能进行密码修改', id: id}));
		}
	} else {
		return next(JSON.stringify({path: `/admin/user-edit`, message: '用户不存在，不能修改', id: id}));
	}
}
```

  app.js

```js
app.use((err, req, res, next) => {
	try {
	// 字符串转换对象
	// {path: `/admin/user-edit`, message: '密码比对失败不能进行密码修改', id: id}
	const result = JSON.parse(err)
	let params = [];
	for (let attr in result) {
		if (attr != "path") {
			params.push(attr + '=' + result[attr]); // message="密码比对失败不能进行密码修改")
		}
	}
	res.redirect(`${result.path}?${params.join("&")}`); // 更灵活，地址和消息不能写死。
	} catch(e) {
		res.send(`e: ${e}, err: ${err}`)
	}
})
```

现在浏览器OK

#### 密码对比成功的处理

`userModify.js`

```js
let isVaild = await bcrypt.compare(password, user.password)
if ( isVaild ) {
			// 更新用户信息到数据库中
			await User.updateOne({_id: id}, {
				username: username,
				email: email,
				role: role,
				state: state
			}) // first arg: 查询条件， second: 修改的用户信息, 密码不能直接写入
```

> 本来应该使用req.body.<>, 但是这么多，太重复了。所以在上面写解构
>
> ```bash
> let { username, email, role, state, password} = req.body
> ```

更新后，重定向到列表页面

```js
			//重定向到用户列表页面
			res.redirect('/admin/user')
```

现在修改用户，输入正常密码后，就可以修改，数据库也一同修改了

### 总代码

userModify.js

```js
let { User, validateUser } = require('../../model/user');
const bcrypt = require('bcrypt');

module.exports = async (req, res, next) => {
	let { id } = req.query;
	let { username, email, role, state, password} = req.body
	
	try {
		await validateUser(req.body)
	} catch(e) {
		// 验证失败
		return next(JSON.stringify({path: `/admin/user-edit`, message: e.message, id: id}));
	}

	let user = await User.findOne({_id: id})

	if (user) {
		// true成功
		// false 失败
		let isVaild = await bcrypt.compare(password, user.password)
		if ( isVaild ) {
			// 更新用户信息到数据库中
			await User.updateOne({_id: id}, {
				username: username,
				email: email,
				role: role,
				state: state
			}) // first arg: 查询条件， second: 修改的用户信息, 密码不能直接写入
			//重定向到用户列表
			res.redirect('/admin/user')
		} else {
			// res.send('密码对比失败')
			return next(JSON.stringify({path: `/admin/user-edit`, message: '密码比对失败不能进行密码修改', id: id}));
		}
	} else {
		return next(JSON.stringify({path: `/admin/user-edit`, message: '用户不存在，不能修改', id: id}));
	}
}
```



## 用户信息删除

### 步骤

1. 点了删除，会弹出窗确认
2. 点了确认就删除，用户id就传递给服务器
3. 就是一个表单

4. 添加隐藏域 用于存储要删除的id值
5. 为删除按钮添加自定义属性存储要删除的用户id
6. 为删除按钮添加事件，在点击事件处理函数中获取自定义属性中存储的id值，并将id值存储在表单的隐藏域中
7. 为删除表单添加请求地址
8. 服务端建立路由
9. 服务端获取id
10. 根据id删除用户

### 添加隐藏域

1. 找到确定删除框 `views/admin/user.art`

   ```html
       <!-- 删除确认弹出框 -->
       <div class="modal fade confirm-modal">
           <div class="modal-dialog modal-lg">
               <form class="modal-content">
                   <div class="modal-header">
                       <button type="button" class="close" data-dismiss="modal"><span>&times;</span></button>
                       <h4 class="modal-title">请确认</h4>
                   </div>
                   <div class="modal-body">
                       <p>您确定要删除这个用户吗?</p>
                   </div>
                   <div class="modal-footer">
                       <button type="button" class="btn btn-default" data-dismiss="modal">取消</button>
                       <input type="submit" class="btn btn-primary">
                   </div>
               </form>
           </div>
       </div>
   ```

   > form标签中，可以看到`<p>您确定要删除这个用户吗?</p>`

2. 在`<p>您确定要删除这个用户吗?</p>`下方添加隐藏域

   ```html
                   <div class="modal-body">
                       <p>您确定要删除这个用户吗?</p>
                       <input type="hidden" name="id">
                   </div>
   ```

3. 现在要找到删除按键，把用户id存储在这个隐藏域中

   ```diff
                           <td>
                               <a href="/admin/user-edit?id={{@ $value._id }}" class="glyphicon glyphicon-edit"></a>
   +                            <i class="glyphicon glyphicon-remove" data-toggle="modal" data-target=".confirm-modal"></i>
                           </td>
   ```

   > 删除按钮就是`i`标签

   在`<i`标签上添加`date-id`自定义属性

   ```html
   <i class="glyphicon glyphicon-remove" data-toggle="modal" data-target=".confirm-modal" date-id="{{@$value._id}}"></i>
   ```

   现在浏览器刷新，F12查看此删除按钮是有此属性的，且值为id

   为此标签启一个类名，方便获取此标签

   ```diff
   +<i class="glyphicon glyphicon-remove delete" 
       data-toggle="modal" data-target=".confirm-modal" date-id="{{@$value._id}}"></i>
   ```

   > 注意最后多了delete

   在user.art文件末尾， 现在找到此标签，测试弹出1

   ```html
   {{ block 'script' }}
       <script type="text/javascript">
           $('.delete').on('click', function () {
               alert(1)
           })
       </script>
   {{ /block }}
   ```

   > 基于类名delete获取，监听click事件，并给一个函数，弹出1

   浏览器刷新后，点了x，会先弹出1，点了确定后，才会有弹出窗

   现在获取用户id

   ```html
   {{ block 'script' }}
       <script type="text/javascript">
           $('.delete').on('click', function () {
               var id = $(this).attr('date-id');
               alert(id)
           })
       </script>
   {{ /block }}
   ```

   > 获取当前`i`标签的属性

   现在要把id存储到隐藏域的value属性中，为了方便获取隐藏域，为隐藏域添加id

   ```html
   <input type="hidden" name="id" id="deleteUserId">
   ```

   然后在获取delete按钮中的jquery事件中完成

   ```diff
   {{ block 'script' }}
       <script type="text/javascript">
           $('.delete').on('click', function () {
               var id = $(this).attr('date-id');
   +            // 将要删除的用户id, 存储在隐藏域中
   +            $('#deleteUserId').val(id)
           })
       </script>
   {{ /block }}
   ```

   浏览器刷新后，先看隐藏域，点了x再看隐藏域

   隐藏域中，会出现id

   ![image-20210914170528417](http://myapp.img.mykernel.cn/image-20210914170528417.png)

​	

###  为表单添加提交地址和方式

`user.art`

```diff
    <!-- 删除确认弹出框 -->
    <div class="modal fade confirm-modal">
        <div class="modal-dialog modal-lg">
+            <form class="modal-content" action="/admin/user-delete" method="GET">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal"><span>&times;</span></button>
                    <h4 class="modal-title">请确认</h4>
                </div>
                <div class="modal-body">
                    <p>您确定要删除这个用户吗?</p>
                    <input type="hidden" name="id" id="deleteUserId">
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default" data-dismiss="modal">取消</button>
                    <input type="submit" class="btn btn-primary">
                </div>
            </form>
```

### 服务端建立路由

`admin.js`

```bash
admin.get('/user-delete', require('./admin/userDelete'));
```

> 删除的用户，上面是GET方法

关联的文件

```js
module.exports = async (req, res) => {
	res.send('删除用户OK')
}
```

浏览器测试，请求是否通，点了提交表单之后，会发现**自动把id作为查询参数传递给后端**

![image-20210914171215708](http://myapp.img.mykernel.cn/image-20210914171215708.png)

### 服务端获取id, 删除用户

`userDelete.js`

```js
const { User } = require('../../model/user');


module.exports = async (req, res) => {
	let { id } = req.query;

	await User.findOneAndDelete({_id: id});
	res.redirect('/admin/user');
}
```



## 文章管理

### 列表页面

文章列表、文章编辑

`http://localhost/admin/article`

`http://localhost/admin/article-edit`

路由`admin.js`

```js
admin.get('/article-edit', require('./admin/articleEditPage'));
admin.get('/article', require('./admin/articlePage'));
```

文章页面 `articlePage.js` 

```js
module.exports = async (req, res)=> {
	res.render('admin/article')
};
```

`articleEditPage.js` 

```js
module.exports = async (req, res) => {
	res.render('admin/article-edit')
};
```

### 侧边栏

为导航添加链接 `views/admin/common/aside.art`

```diff
+                    <a class="item active" href="/admin/user">
						<span class="glyphicon glyphicon-user"></span>
						用户管理
					</a>
                </li>
                <li>
+                    <a class="item" href="/admin/article">
```

现在页面是可以切了，但是无论怎么点，始终都在用户管理上是选中状态的

谁当前选中，为对应的a标准添加active即可

现在怎么知道，谁当中被选中呢？ 可以在路由中设定一个标识，标识当前是xx管理页面。

`userPage.js`

```js

module.exports = async (req, res)=> {

	// 全局属性
	req.app.locals.currentLink = 'user'
```

`userEditPage.js`

```js

module.exports = async (req, res, next)=> {

	// 全局属性
	req.app.locals.currentLink = 'user'
```

`articlePage.js`

```js
module.exports = async (req, res)=> {
	// 全局属性
	req.app.locals.currentLink = 'article'
	
	res.render('admin/article')
};

```

`articleEditPage.js`

```js
module.exports = async (req, res) => {
	// 全局属性
	req.app.locals.currentLink = 'article'
	
	res.render('admin/article-edit')
};
```

`aside.art`

```diff
+                    <a class="item {{ currentLink == "user" ? 'active' : ''}}" href="/admin/user">
						<span class="glyphicon glyphicon-user"></span>
						用户管理
					</a>
                </li>
                <li>
+                    <a class="item {{ currentLink == "article" ? 'active' : ''}}" href="/admin/article">
```



### 准备文章数据表集合

只有有了表，才可以添加文章

文章的字段，查看`http://localhost/admin/article-edit`

标题、作者（对应1个）、发布时间、文章封面、内容

![image-20210915113144936](http://myapp.img.mykernel.cn/image-20210915113144936.png)

准备数据结构`model/article.js`

```js
const mongoose=require('mongoose');


// 创建文章规则集合
const ArticleSchema = new mongoose.Schema({
	title: {
		type: String,
		required: [true, '请填写文章标题，数据库对数据的判断'],
		minlength: 4,
		maxlength: 20
	},
	anthor: { // 实际上就是用户集合的作者
		type: mongoose.Schema.Types.ObjectId,
		ref: 'User', // 属性写集合名  mongoose.model('User', UserSchema); 就是引号中的名称
		required: [true, '请传递作者']
	},
	publishDate: { // 不应该是必选字段，用户不给时间，默认当前时间
		type: Date,
		default: Date.now
	},
	cover: { // 文章封面
		type: String,
		default: null //数据据中为null
	},
	content: {
		type: String,
		requird: true
	}
})

// 创建集合
const Article = mongoose.model('Article', ArticleSchema);


// 导出集合
module.exports = {
	Article
}
```

> required, 可以直接接true, 或者接数组。第1个参数bool值，意义同单值。第2个参数，表示不给此值时，将会报错信息。

### 添加文章

#### 步骤

1. 文章跳转
2. 编辑页面，form方法、地址、每个字段添加name属性（当涉及上传时，需要修改编码类型）
3. 服务端路由、添加上传功能。

#### 基础操作

准备文章页面`http://localhost/admin/article-edit`

文章列表页面，点按钮就跳转`/admin/article-edit`

```diff
                <a href="/admin/article-edit" class="btn btn-primary new">发布新文章</a>
```



路由及渲染

```js
admin.get('/article-edit', require('./admin/articleEditPage'));
```

> ```js
> module.exports = async (req, res) => {
> 	// 全局属性
> 	req.app.locals.currentLink = 'article'
> 	
> 	res.render('admin/article-edit')
> };
> ```

点提交前检验数据 `admin/article-edit.art`

1. 获取表单和添加name属性

   ```diff
               <!-- /分类标题 -->
               <!--
                   enctype 指定表单的编码类型
                       application/x-www-form-urlencoded 默认编码: name=zhangsan&age=20
                       multipart/form-data               将表单数据编码成二进制类型，如果表单涉及到文件上传。
               -->
   +            <form class="form-container addarticle" enctype="multipart/form-data" method="POST" action="/admin/article-add">
                   <div class="form-group">
                       <label>标题</label>
   +                    <input name="title" type="text" class="form-control" placeholder="请输入文章标题">
                   </div>
                   <div class="form-group">
                       <label>作者</label>
   +                    <input  name="author" type="text" class="form-control" readonly>
                   </div>
                   <div class="form-group">
                       <label>发布时间</label>
   +                    <input  name="publishDate"  type="date" class="form-control">
                   </div>
                   
                   <div class="form-group">
                      <label for="exampleInputFile">文章封面</label>
   +                   <input   type="file" name="cover">
                      <div class="thumbnail-waper">
                          <img class="img-thumbnail"   src="">
                      </div>
                   </div>
                   <div class="form-group">
                       <label>内容</label>
   +                    <textarea class="form-control" id="editor"  name="content" ></textarea>
                   </div>
                   <div class="buttons">
                       <input type="submit" class="btn btn-primary">
                   </div>
               </form>
   ```

   > 注意：form表单一定要是 `mulipart/form-data` 才可以正常执行

2. 添加jquery script

   ```diff
   {{ /block }}
    {{ block 'script' }} 
       <script src="lib/ckeditor5/ckeditor.js"></script>
       <script type="text/javascript">
       
           let editor;
   
           ClassicEditor
                   .create( document.querySelector('#editor'))
                   .then(newEditor => {
                       editor = newEditor;
                   })
                   .catch( error => {
                       console.error( error );
                   });
   
           // 获取数据
           // const editorData = editor.getData();
       </script>
   
   +    <script type="text/javascript">
   +        $('.addarticle').on('submit', function () {
   +            var result = serializeToJson($(this))
   +            console.log(result);
   +            // 阻止默认提交
   +            return false;
   +        });
   +    </script>
   {{ /block }}
   ```

   浏览器测试, 取消阻止默认提交

准备文件添加的路由

`admin.js`

```js
admin.post('/article-add', require('./admin/articleEdit'));
```

> ```js
> module.exports = (req, res) => {
> 	res.send('添加ok')
> }
> ```



#### 接收上传参数，完成上传

之前使用`req.body`, 修改`articleEdit`

```js
module.exports = (req, res) => {
	res.send(req.body)
}
```

> 浏览器返回 `{"title":"","author":"","publishDate":"","cover":"BCClipboard.exe","content":"<p>123</p>"}` 所以并不能处理二进制参数



到底怎么接收客户端的二进制数据，需要使用`formidable`第3方模块，用来解析表单。即支持get/post请求参数，重要的是支持文件上传

```js
const formidable = require('formidable');


// 创建表单解析对象 
const form = new formidable.IncomingForm()


// 设置文件上传路径 
form.uploadDir = "/my/dir";

// 默认客户端上传的文件没有后缀名。现在需要保留后缀。 是否保留扩展名
form.keepExtensions = false


// 对表单解析
form.parse(req, (err, fields, files) => {
    // err 解析失败时，会保存错误对象。成功时，是null.
    // fields 存储普通的请求参数;  key=value
    // files 存储上传的文件信息;
})
```



编辑`articleEdit.js`

```js
const formidable = require('formidable');
const path = require('path');

module.exports = (req, res, next) => {
	// 创建表单解析对象 
	let options = { 
		multiples: false, 
		uploadDir: path.join(__dirname, "../../public/uploads"), 
		keepExtensions: true 
	}
	let form = new formidable(options);

	form.parse(req, (err, fields, files) => {
		// err 错误信息，表单解析成功就是null, 失败就是err.
		// fields 普通表单数据
		// files 对象，保存了上传文件相关的数据
		res.send(fields);
	});
} 
```

> 注意：form表单一定要是 `mulipart/form-data` 才可以正常执行
>
> 安装模块
>
> ```bash
> $ npm install formidable
> ```
>
> 准备uploads目录
>
> ```bash
> install -dv public/uploads/
> ```
>
> 访问结果:
>
> `"title":"123123","author":"","publishDate":"2021-09-17","content":"<p>1231</p>"}`
>
> 没有文件:，如果把`res.send(fields);` 替换成
>
> ```js
> res.send(files);
> ```
>
> >  刷新网页得到以下。
>
> > `{"cover":{"size":114595,"path":"I:\\python24\\blog\\public\\uploads\\upload_6ceea9dc3a4b1775543cee884e33b325.ico","name":"app.ico","type":"image/x-icon","mtime":"2021-09-16T13:30:54.224Z"}}`
> >
> > 避免冲突，所以有一个独一无二的名称: `upload_6ceea9dc3a4b1775543cee884e33b325.ico`， 此有后缀
>
> ![image-20210916213449988](http://myapp.img.mykernel.cn/image-20210916213449988.png)



#### 作者参数

当前登陆用户的id, 登陆后在`app.locals`中有用户信息 `login.js`, `app.locals`中的变量在模板中可以使用

```js
	if (user) {
		// 查询到	
		let isValidate = await bcrypt.compare(password, user.password)
		if (isValidate) {
			req.session.username = user.username;
			req.app.locals.userInfo = user;
			res.redirect('/admin/user')
			return ;
		} else {
```

在article-eidt.art中

```diff
                <div class="form-group">
                    <label>作者</label>
+                    <input type="text" class="form-control" readonly name="author" value="{{@ userInfo._id}}">
```

> 现在需要打开用户登陆功能，在`app.js`文件中
>
> ```diff
> +app.use('/admin', guard)
> 
> // 为路由对象映射请求路径
> app.use('/home', home);
> app.use('/admin', admin);
> ```
>
> ![image-20210916215725798](http://myapp.img.mykernel.cn/image-20210916215725798.png)

#### 用户选了文件，把封面图片显示

javascript读图片，读取的图片显示在页面中, 文件读取FileReader

```js
var reader = new FileReader();
reader.readAsDataURL('文件'); // 读取的二进制数据
reader.onload = function () {
    console.log(reader.result);
}
```

找到文件选择控件，添加onChange事件，用户选择完图片之后，读取文件，把文件二进制数据放在src=上, `article-edit.art`

```diff
                <div class="form-group">
                   <label for="exampleInputFile">文章封面</label>
+                   <input type="file" name="cover" id="file">
                   <div class="thumbnail-waper">
                       <img class="img-thumbnail" src="/admin/">
                   </div>
                </div>
```

> 添加`id`属性

获取input, 添加事件

1. 获取多个文件

```js
    <script type="text/javascript">
        // 选择上传控件
        var file = document.querySelector('#file');
        file.onchange = function() {
            // 用户选择完文件后
            // 1. 创建文件读取对象
            var reader = new FileReader();
            // 用户选择的文件列表
            console.log(this.files) 
        }
    </script>
```

> > 此脚本也可以放在其他脚本之后，也可以另起一个标签包含，如同上面一样。
>
> 浏览器选择文件，后浏览器查看控制台
>
> ![image-20210916220743551](http://myapp.img.mykernel.cn/image-20210916220743551.png)
>
> 要想用户可以选择多个文件，需要在 `article-edit.art`文件中的`input`标签添加属性
>
> ```diff
> +  <input type="file" name="cover" id="file" multiple>
> ```
>
> 刷新网页后，选择多个文件后，可以查看filelist结果，可以看到多文件列表 
>
> ![image-20210916221420103](http://myapp.img.mykernel.cn/image-20210916221420103.png)
>
> 由于我们当前只需要选择1个文件，所以我们可以去掉multiple属性



2. 获取单个文件的结果

   ```diff
       <script type="text/javascript">
           // 选择上传控件
           var file = document.querySelector('#file');
           file.onchange = function() {
               // 用户选择完文件后
               // 1. 创建文件读取对象
               var reader = new FileReader();
               // 用户选择的文件列表
   +            console.log(this.files[0]) 
           }
       </script>
   ```

   浏览器器返回的结果

   ```js
   File(795120) {name: "npjlgplayer3.dll", lastModified: 1630934234409, lastModifiedDate: Mon Sep 06 2021 21:17:14 GMT+0800 (中国标准时间), webkitRelativePath: "", size: 795120, …}
   ```

3. 读取文件

   ```diff
       <script type="text/javascript">
           // 选择上传控件
           var file = document.querySelector('#file');
           file.onchange = function() {
               // 用户选择完文件后
               // 1. 创建文件读取对象
               var reader = new FileReader();
               // 用户选择的文件列表
   +            // console.log(this.files[0]) 
   +            // 2. 读取文件, 是异步的方法，不能直接接这个文件的结果，需要监听onload获取文件。
   +            reader.readAsDataURL(this.files[0]); 
   +            // 3. 监听onload事件
   +            reader.onload = function () {
   +                // 文件读取完成时，将会调用此函数
   +                console.log(reader.result);
   +            };
           }
       </script>
   ```

   > 现在刷新页面，可以看到控制台已经有数据了
   >
   > ![image-20210916222325334](http://myapp.img.mykernel.cn/image-20210916222325334.png)
   >
   > 现在把这个数据放在img的src属性上，此图片将会显示出来。

4. 把编码放在src属性上

   为了方便获取img标签，添加id标签

   ```diff
                      <input type="file" name="cover" id="file" multiple>
                      <div class="thumbnail-waper">
   +                       <img class="img-thumbnail" src="/admin/" id="preview">
                      </div>
   ```

   现在获取preview控件

   ```diff
       <script type="text/javascript">
   +        var preview = document.querySelector('#preview');
           // 选择上传控件
           var file = document.querySelector('#file');
   ```

   现在给preview添加属性

   ```diff
               reader.readAsDataURL(this.files[0]); 
               // 3. 监听onload事件
               reader.onload = function () {
                   // 文件读取完成时，将会调用此函数
                   console.log(reader.result);
   +                preview.src = reader.result;
               };
           }
       </script>
   ```

   > 现在图片就即时预览了
   >
   > ![image-20210916222846890](http://myapp.img.mykernel.cn/image-20210916222846890.png)

#### 将用户上传的文章写入数据库

文章封面已经上传到/public/uploads/文件中, 数据库cover字段存储图片的路径。

上传的图片信息，由files记录，测试查看files的结果 views/admin/article-add.art

```diff
module.exports = (req, res, next) => {
	// 创建表单解析对象 
	let options = { 
		multiples: false, 
		uploadDir: path.join(__dirname, "../../public/uploads"), 
		keepExtensions: true 
	}
	let form = new formidable(options);

	form.parse(req, (err, fields, files) => {
		// err 错误信息，表单解析成功就是null, 失败就是err.
		// fields 普通表单数据
		// files 对象，保存了上传文件相关的数据
+		res.json(files);
	});
} 
```

重新测试上传图片，提交后，浏览器会显示以下结果。

```json
{"cover":{"size":55361,"path":"I:\\python24\\blog\\public\\uploads\\upload_b609e0a0d0cb425f9e7995119d27e62a.png","name":"y.png","type":"image/png","mtime":"2021-09-16T14:33:56.702Z"}}
```

> path属性就是文件路径。就是服务端（电脑）上的路径， 其他用户不能直接访问这个路径，所以数据库存储的应该是静态文件路径。`/uploads/upload_b609e0a0d0cb425f9e7995119d27e62a.png`, 因为静态资源识别的/就是服务器的/



获取路径, 在article-add.js文件中的解析方法中

```js
	form.parse(req, (err, fields, files) => {
		// err 错误信息，表单解析成功就是null, 失败就是err.
		// fields 普通表单数据
		// files 对象，保存了上传文件相关的数据
		res.json(files.cover.path.split('public')[1]);
	});
} 
```

> 浏览器结果`"\\uploads\\upload_046b6ea8156e220ffa85a1ed06cecafd.png"`



文章集合中插入数据, 在article-add.js文件中的解析方法中,

```js
	form.parse(req, async (err, fields, files) => {
		// err 错误信息，表单解析成功就是null, 失败就是err.
		// fields 普通表单数据
		// files 对象，保存了上传文件相关的数据
		// res.json(files.cover.path.split('public')[1]);

		await Article.create({
			title: fields.title,
			author: fields.author,
			publishDate: fields.publishDate,
			cover: files.cover.path.split('public')[1],
			content: fields.content
		})
		res.redirect('/admin/article')
	});
```
### 文章列表

#### 基础操作+分页 (方法1)

**如果想看分步骤，先展示所有，再分页。请看3.6介绍的用户展示、用户分页。**



访问`http://localhost/admin/article`

配置路由`admin.js`

```js
admin.get('/article', require('./admin/articlePage'));
```

> 相关的js文件
>
> ```js
> let { Article } = require('../../model/article');
> 
> module.exports = async (req, res)=> {
> 	// 全局属性
> 	req.app.locals.currentLink = 'article'
> 	
> 	let page  = req.query.page || 1;
> 
> 	let count = await Article.countDocuments({});
> 
> 	let pagesize = 10
> 
> 	let total_page = Math.ceil(count/pagesize);
> 
> 	// res.send(`page: ${page}, count: ${count}, total_page: ${total_page}`)
> 
> 	let start = (page - 1) * pagesize
> 	// return;
> 	let articles = await Article.find({}).populate('author').limit(pagesize).skip(start).lean()
> 	//https://blog.csdn.net/qq_40659195/article/details/88411838
> 	// 存的id, 怎么显示用户名
> 	// let articles = await Article.find({}).populate('author')
> 
> 	res.render('admin/article', {
> 		articles: articles, 
> 		page, // 前后页
> 		total_page // 中间
> 	})
> };
> ```
>
> > `lean()`默认文档
> >
> > populate() 将字段通过关联查询出另一个表_id字段匹配的行。

配置`admin/article`模板

```diff
                <tbody>
+                    {{ each articles }}
                    <tr>
+                        <td>{{@ $value._id }}</td>
+                        <td>{{ $value.title }}</td>
                        <!--
                        处理日志格式
                        -->
+                        <td>{{ dateFormat($value.publishDate, 'yyyy-mm-dd') }}</td>
                        <!--
                        显示用户名 OK
                        -->
+                        <td>{{ $value.author.username }}</td>
                        <td>
                            <!--
                                文章编辑时，传递作者的id, 还是文章id?
                                文章id: 惟一
                                作者id, 由于1个作者多个文章，肯定会查多个文章出来
                            -->
+                            <a href="/admin/article-edit?id={{@ $value._id }}" class="glyphicon glyphicon-edit"></a>
                            <i class="glyphicon glyphicon-remove" data-toggle="modal" data-target=".confirm-modal"></i>
                        </td>
                    </tr>
                    {{ /each}}
                </tbody>
            </table>
            <!-- /内容列表 -->
            <!-- 分页 -->
            <ul class="pagination">
            	<!--
            	浏览器查找 .pagination>li的style, 确定下面的style
            	-->
+                <li style="display: {{ page-1 < 1 ? 'none' : 'inline'}}">
+                    <a href="/admin/article?page={{page-1}}">
			        <span>&laquo;</span>
			      </a>
                </li>
+                <% for (let i=1; i<=total_page; i++) { %>
+                <li><a href="/admin/article?page={{i}}">{{i}}</a></li>
+                <% } %>
+                <li style="display: {{ page-0+1 > total_page ? 'none' : 'inline'}}">
+                    <a href="/admin/article?page={{page-0+1}}">
			        <span>&raquo;</span>
			      </a>
                </li>
            </ul>
            <!-- /分页 -->
        </div>
```

> `<td>{{ dateFormat($value.publishDate, 'yyyy-mm-dd') }}</td>`
>
> 依赖模板引擎中引入dateFormat函数，在`app.js`中引入模块
>
> 1. 安装
>
>    ```bash
>    $ npm install --save dateformat
>    ```
>
> 2. 引入 `app.js`第1行
>
>    ```js
>    const dataFormat = require('dateformat');
>    const template = require('art-template');
>    ```
>
> 3. 配置 
>
>    ```diff
>    // 配置express框架，模板基础位置，及其默认后缀. 配置指定后缀使用什么模板引擎
>    app.set('views', path.join(__dirname, './views')); // first arg: views固定, 模板位置
>    app.set('view engine', 'art'); // second arg: 模板固定后缀
>    app.engine('art', require('express-art-template')); //first arg: 什么后缀；second arg: 指定什么引擎
>    +// express-art-template, 也同时会下载art-template
>    +// 给模块内部导入外部变量， 模块中才可以调用这个方法。
>    +template.defaults.imports.dateFormat = dataFormat; 
>    ```
>
> `<td>{{ $value.author.username }}</td>` 由于在`articlePage.js`文件中已经将author原来的id转换成对象了所以可以直接使用。

网页展示的结果

![image-20210917105501623](http://myapp.img.mykernel.cn/image-20210917105501623.png)

#### 展示 结合mongoose-sex-page分页 (方法2)

```js
const pagination = requite('mongoose-sex-page');
pagination(集合构建函数).page(1).size(20).display(8).exec();
```

> page当前页
>
> size 每页显示数据条数
>
> display 客户端显示的页码数量。**之前我们使用自己的程序逻辑来显示总页数，如果100页的时候，用户体验不好。所以使用此指定客户端显示几个页面。**
>
> exec 像数据库发出查询请求

查询的返回结果

```yaml
{
	"page": 1,   // 当前页
	"size": 2,   //  每页显示数据条数
	"total": 8, //  总数据
	“records": [
		//查询出来的具体数据
		{},
		{},
		...
	],
	"pages": , //总页数
	"display": [1,2,3,4] //客户端显示的页数
}
```



命令行工具，安装模块

```bash
npm install --save mongoose-sex-page
```

在`articlePage.js`显示数据格式

```js
let { Article } = require('../../model/article');
const pagination = require('mongoose-sex-page');

module.exports = async (req, res)=> {
	// 全局属性
	req.app.locals.currentLink = 'article'

	let page = req.query.page || 1;
	// page 当前页
	// size 每页条数
	// display 显示页码数量
	let articles = await pagination(Article).find({}).page(page).size(10).display(3).populate('author').exec()


	res.render('admin/article', {
		articles: articles, 
	})
};

```

> 现在浏览器返回的数据结构
>
> ```yaml
> {
> "page": 1,
> "size": 10,
> "total": 44,
> "records": [
>     {
>     "_id": "6143eb7d96ffc2615bbc78f8",
>     "title": "hello world",
>     "author": {
>     "_id": "61402d3e13e3b84d8a324041",
>     "username": "zhuwu",
>     "email": "zhuwu@itcast.cn",
>     "password": "$2b$10$1c4KdEJ3rBikAH3eYeYWi.HGH5GEEKFSuoSuSB2b1FhffMxuHdsn6",
>     "role": "normal",
>     "state": 0,
>     "__v": 0
>     },
>     "publishDate": "2021-09-17T00:00:00.000Z",
>     "cover": "\\uploads\\upload_70a9d92f396b6f01756b917a5be4c9a6.jpg",
>     "content": "<p>hello world</p>",
>     "__v": 0
>     }
> ],
> "pages": 5,
> "display": [1,2,3]
> }
> ```
>
> > 当前页



在`articlePage.js` 渲染页面

```js
let { Article } = require('../../model/article');
const pagination = require('mongoose-sex-page');

module.exports = async (req, res)=> {
	// 全局属性
	req.app.locals.currentLink = 'article'

	// page 当前页
	// size 每页条数
	// display 显示页码数量
	let articles = await pagination(Article).find({}).page(1).size(10).display(3).populate('author').exec()

	res.render('admin/article', {
		articles: articles, 
	})
};
```

> 为避免出问题，需要降低mongo版本
>
> ```bash
>  npm install --save mongoose@5.4.0
> ```
>
> 

配置模板

```diff
                <tbody>
+                    {{ each articles.records }}
                    <tr>
                        <td>{{@ $value._id }}</td>
                        <td>{{ $value.title }}</td>
                        <!--
                        处理日志格式
                        -->
                        <td>{{ dateFormat($value.publishDate, 'yyyy-mm-dd') }}</td>
                        <!--
                        显示用户名 OK
                        -->
                        <td>{{ $value.author.username }}</td>
                        <td>
                            <!--
                                文章编辑时，传递作者的id, 还是文章id?
                                文章id: 惟一
                                作者id, 由于1个作者多个文章，肯定会查多个文章出来
                            -->
                            <a href="/admin/article-edit?id={{@ $value._id }}" class="glyphicon glyphicon-edit"></a>
                            <i class="glyphicon glyphicon-remove" data-toggle="modal" data-target=".confirm-modal"></i>
                        </td>
                    </tr>
                    {{ /each}}
                </tbody>
```

配置页码 及翻页

```diff
            <ul class="pagination">
+                <li style="display: {{ articles.page-1 < 1 ? 'none' : 'inline'}}">
+                    <a href="/admin/article?page={{articles.page-1}}">
			        <span>&laquo;</span>
			      </a>
                </li>
+                <% for (let i=0; i<=articles.display.length-1; i++) { %>
+                <li><a href="/admin/article?page={{articles.display[i]}}">{{articles.display[i]}}</a></li>
+                <% } %>
+                <li style="display: {{ articles.page-0+1 > articles.pages ? 'none' : 'inline'}}">
+                    <a href="/admin/article?page={{articles.page-0+1}}">
			        <span>&raquo;</span>
			      </a>
                </li>
            </ul>
```

或者

```diff
            <ul class="pagination">
+                {{ if articles.page > 1}}
                <li>
+                    <a href="/admin/article?page={{articles.page-1}}">
			        <span>&laquo;</span>
			      </a>
                </li>
+                {{/if}}
+                <% for (let i=0; i<=articles.display.length-1; i++) { %>
+                <li><a href="/admin/article?page={{articles.display[i]}}">{{articles.display[i]}}</a></li>
+                <% } %>
+                {{ if articles.page < articles.pages }}
                <li>
+                    <a href="/admin/article?page={{articles.page-0+1}}">
			        <span>&raquo;</span>
			      </a>
                </li>
+                {{/if}}
            </ul>
```

### 修改文章

和3.7一致

1. 用户点了修改，就访问edit页面，需要带上id
2. 用户edit页面中，自动填充id对应的所有值
3. 用户edit页面，渲染时，判断有id就请问modify接口，没有id就请求add接口
4. 修改后，就跳转文章页

修改文章页面article.js

```diff
                        <td>
                            <!--
                                文章编辑时，传递作者的id, 还是文章id?
                                文章id: 惟一
                                作者id, 由于1个作者多个文章，肯定会查多个文章出来
                            -->
+                            <a href="/admin/article-edit?id={{@ $value._id }}" class="glyphicon glyphicon-edit"></a>
```

> 还是重复请求文章添加路由，只是添加一个id参数

修改路由`admin.js`

```js
admin.get('/article-edit', require('./admin/articleEditPage'));
```

> ```js
> let { Article } = require('../../model/article')
> module.exports = async (req, res) => {
> 	// 全局属性
> 	req.app.locals.currentLink = 'article'
> 	
> 	let { id } = req.query;
> 
> 	if (id) {
> 		let article = await Article.findOne({_id: id})
> 
> 
> 		res.render('admin/article-edit',{
> 			article,
> 			link:`/admin/article-modify?id=${id}`
> 		})
> 	} else {
> 		res.render('admin/article-edit',{
> 			link: "/admin/article-add"
> 		})
> 	}
> 	
> };
> ```
>
> 带了id参数就渲染时，把请求路由指定修改路由

配置文章编辑模板`article-edit.art`

```diff
            <div class="title">
+                <h4 style="display: {{ artile ? 'block' : 'none'}}">{{@ article && article._id }}</h4>
            </div>
```

> 添加就不显示。修改就显示当前文章的id

```diff
           <!--
                enctype 指定表单的编码类型
                    application/x-www-form-urlencoded 默认编码: name=zhangsan&age=20
                    mutilpart/form-data               将表单数据编码成二进制类型，如果表单涉及到文件上传。
            -->
+            <form class="form-container addarticle" enctype="multipart/form-data" method="POST" action="{{link}}">
                <div class="form-group">
                    <label>标题</label>
+                    <input name="title" type="text" class="form-control" placeholder="请输入文章标题" value="{{@ article && article.title }}">
                </div>
                <div class="form-group">
                    <label>作者</label>
                    <!--
                        使用id是惟一的，方便修改时，引用id来查询

                        修改时，引用文章对应的作者
                    -->
+                    <input  name="author" type="text" class="form-control" readonly value="{{@ userInfo && userInfo._id || ( article && article.author)  }}">
                </div>
                <div class="form-group">
                    <label>发布时间</label>
                    <!-- 
                    文章时间如何转换
                    -->
+                    <input  name="publishDate"  type="date" class="form-control" value="{{ article && dateFormat(article.publishDate, 'yyyy-mm-dd')}}">
                </div>
                
                <div class="form-group">
                   <label for="exampleInputFile">文章封面</label>
                   <input   type="file" name="cover" id="file" multiple>
                   <div class="thumbnail-waper">
+                       <img class="img-thumbnail"  src="{{ article && article.cover  }}" id="addimg"      width="300"  height="400">
                   </div>
                </div>
                <div class="form-group">
                    <label>内容</label>
+                    <textarea class="form-control" id="editor"  name="content" value="{{ article && article.content }}" ></textarea>
                </div>
                <div class="buttons">
                    <input type="submit" class="btn btn-primary">
                </div>
            </form>
```

> `{{link}}` 用户点了提交就请求不同的路由
>
> 其他都是，只要带了id, 就会传递此文章id对应的文章到模板，模板就会判断有文章就添加默认值

```diff
{{ block 'script' }} 
    <script src="lib/ckeditor5/ckeditor.js"></script>
    <script type="text/javascript">
    
        let editor;

+        var content = document.querySelector('#editor')
        ClassicEditor
                .create( document.querySelector('#editor'))
                .then(newEditor => {
                    editor = newEditor;
+                    let value = content.getAttribute('value')
+                    if (value) {
+                        console.log(value)
+                        editor.setData(value);
+                    }
                })
                .catch( error => {
                    console.error( error );
                });

        // 获取数据
        // const editorData = editor.getData();


+        var file = document.querySelector('#file')
+        var preview = document.querySelector('#addimg')
+        file.onchange = function () {
+            var reader = new FileReader();
+            reader.readAsDataURL(this.files[0]);
+            reader.onload = function () {
+                console.log(reader.result)
+                preview.src = reader.result;
+            }
+        }
    </script>

    <script type="text/javascript">
+        $('.addarticle').on('submit', function () {
+            var result = serializeToJson($(this))
+            console.log(result);
+            // 阻止默认提交
+            // return false;
+        });
    </script>
{{ /block }}
```

> - 获取渲染时，给html的内容标签的value值，并通过editor 富文本编辑器将此值显示在页面上。
>
> - 只要file选择框变化了，就将文件加载到img的src属性上，在页面预览
> - 阻止默认提交，检验用户填的数据

修改路由

```js

const formidable = require('formidable'); 
const path = require('path');
let { Article } = require('../../model/article')
module.exports = async (req, res) => {
	// 全局属性
	req.app.locals.currentLink = 'article'
	
	let { id } = req.query;

	// 1. 创建表单解析对象
	const form = new formidable.IncomingForm()

	// 2. 设置文件上传路径, 上传到public中的uploads文件中。
	form.uploadDir = path.join(__dirname,"../../public/uploads/");

	// 默认客户端上传的文件没有后缀名。现在需要保留后缀。 是否保留扩展名
	form.keepExtensions = true

	// 对表单解析
	form.parse(req, async (err, fields, files) => {
	    // err 解析失败时，会保存错误对象。成功时，是null.
	    // fields 存储普通的请求参数; 除了二进制文件的其他数据  key=value
	    // files 存储上传的文件信息;
	    if (files.cover.name) {
	    	// 上传
		    await Article.updateOne({_id: id},{
		    	title: fields.title,
		    	author: fields.author,
		    	publishDate: fields.publishDate,
		    	cover: files.cover.path.split('public')[1],
		    	content: fields.content
		    })
	    } else {
	    	// 更新
		    await Article.updateOne({_id: id},{
		    	title: fields.title,
		    	author: fields.author,
		    	publishDate: fields.publishDate,
		    	content: fields.content
		    })
	    }
		res.redirect('/admin/article')
	});
	// res.send('ok');

};
```

> 通过观察，发现只要不上传文件，files.cover.name属性没有值，就只更新其他字段。否则更新所有
>
> 最后会跳转文章页面



### 删除文章

和3.8一样

1. 用户点了删除，此删除的标签上会附带此用户id, 会触发一个click事件把此标签的用户id拿出来放在删除modal中的hidden input标签的值上
2. 配置删除form的地址，用户点了GET 删除，浏览器会自动把 input的name属性的值=value属性的值, 放在请求的地址后

文章页面，配置删除时带id `article.art`

```diff
                            <a href="/admin/article-edit?id={{@ $value._id }}" class="glyphicon glyphicon-edit"></a>
+                            <i class="glyphicon glyphicon-remove delete" data-toggle="modal" data-target=".confirm-modal" data-id="{{@ $value._id}}"></i>
```

配置隐藏域，并给name, 当用户点了确认，浏览器会自动将name的值=value的值。 `localhost/admin/user-delete?id=xxxx`

```diff
    <!-- 删除确认弹出框 -->
    <div class="modal fade confirm-modal">
        <div class="modal-dialog modal-lg">
+            <form class="modal-content" action="/admin/article-delete" method="GET">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal"><span>&times;</span></button>
                    <h4 class="modal-title">请确认</h4>
                </div>
                <div class="modal-body">
                    <p>您确定要删除这篇文章吗?</p>
+                    <input type="hidden" id="delete" name="id">
                </div>
```

> 删除的地址及方法

脚本

```diff
{{ block 'script' }} 
    <script text="text/javascript">
        $('.delete').on('click', function () {
            $('#delete').val($(this).attr('data-id'))
        })
    </script>
{{ /block }}
```

> 将id写入隐藏域

删除路由 `admin.js`

```js
admin.get('/user-delete', require('./admin/userDelete'));
```

`userDelete.js`

```js
const { User } = require('../../model/user');


module.exports = async (req, res) => {
	let { id } = req.query;

	await User.findOneAndDelete({_id: id});
	res.redirect('/admin/user');
}
```

## mongodb添加账号

### mongodb服务认证启动

mongodb默认不需要认证，非常危险

查看数据库

```bash
show dbs
```

创建超级管理员, 切换到admin数据库

```js
use admin
db.createUser({
	user: 'root', //用户名
	pwd: 'root',  //密码
    roles: [
        'root'    // 默认角色root，就是超级管理员
    ]
})
```

> 创建成功后`Successfully added user: { "user" : "root", "roles" : [ "root" ] }`
>
> 测试登陆
>
> ```bash
> # mongo  -u root -p root --authenticationDatabase admin
> ```
>
> 

创建普通账号

```bash
use blog
db.createUser({
	user: 'blog', //用户名
	pwd: 'blog',  //密码
    roles: [
        'readWrite'    // 默认普通账号 readWrite 对数据库有读写权限：CURD。
    ]
})
```

> 创建成功后: `Successfully added user: { "user" : "blog", "roles" : [ "readWrite" ] }`
>
> 测试登陆
>
> ```bash
> # mongo  -u blog -p blog --authenticationDatabase blog
> ```
>
> 

删除mongodb服务

```bash
mongod --remove
```

创建mongod服务, 并添加认证

```bash
docker run -itd --name mongo -p 27017:27017 mongo --auth
```

### 认证方式连接mongo

`model/connect.js`

```js
mongoose.connect('mongodb://blog:blog@localhost/blog').then(() => console.log('mongo db connect success.')).catch( () => console.log('mongo db connect failed.'));
```

现在打开`model/user.js` 注释，可以发现navicat中的mongo有数据了。

```js
// async function createUser(username) {
// 	let salt = await bcrypt.genSalt(10); // 默认10位
// 	let pass = await bcrypt.hash('12345', salt);

// 	const user = await User.create({
// 	username: username,
// 	email: `${username}@itcast.cn`,
// 	password: pass,
// 	role: 'normal',
// 	state: 0
// 	});
// 	return user;
// }

// names = ["shijin", "zhuwu", "chengda", "yangchun", "luzhishen", "lizhong", "zhoutong", "lingchong", "chaijin", "zhugui", "luqian", "songwan", "yangzhi", "suochao", "leiheng", "liutang",
// "wuyong", "ruanxiaoer", "runxiaowu", "ruanxiaoqi", "gongsunsheng", "baisheng", "baisheng", "chaozheng", "songjiang", "songqing", "wusong", "zhangqing", "sunerniang", "shieng",
// "kongming", "kongliang", "yanshun", "wangying"]

// for (var i=0; i<names.length; i++) {
// 	createUser(names[i])
// }  
```

然后删除navicat中的数据，删除connect.js的用户和密码然后保存文件，可以发现数据据不能写入, 并报错

```bash
(node:2756) UnhandledPromiseRejectionWarning: MongoError: command insert require
s authentication
```

## 开发和生产环境

### 环境变量区分不同环境

| 环境     | 数据库   |
| -------- | -------- |
| 开发环境 | 本地单机 |
| 生产环境 | 高可用   |

> 2者地址和密码一定不一样

所以在项目启动时，就要**依据系统环境变量**判断不同的环境，加载不同的配置。

```bash
NODE_ENV=development // 代表开发环境
NODE_ENV=production  // 代表生产环境
```



1. 查看变量

现在在`app.js`中依据变量来区别不同的环境 , 在引入路由前`app.use('/home', home); \n app.use('/admin', admin);`

```js
// 获取系统环境变量，返回对象。对象中存储所有环境变量。
console.log(process.env) 

```

> 命令行输出
>
> ```bash
> $ export NODE_ENV="development" ; nodemon app.js
> ```
>
> ![image-20210917152748574](http://myapp.img.mykernel.cn/image-20210917152748574.png)

2. 获取环境变量

   替换第1步的代码

   ```js
   // 获取系统环境变量，返回对象。对象中存储所有环境变量。
   console.log(process.env.NODE_ENV) 
   ```

   > 命令行工具，就有这个值了

3. 判断环境

   替换以上代码

   ```js
   if (process.env.NODE_ENV == "development") {
   	// 开发
   	console.log('开发')
   }  else {
   	// 生产
   	console.log('生产环境')
   }
   ```

   > 命令行工具，就会显示生产环境
   >
   > 现在更新环境变量，就自动输出生产环境了

### 开发输出访问日志

客户端请求打印到控制台, 在以上的开发逻辑部分, 粘贴以下代码. 注意在：路由前

```js
	// 开发环境中，客户端请求到服务端的请求信息打印到控制台中。请求、响应
	app.use(morgan('dev'))
```

> 准备模块
>
> ```bash
> npm install --save morgan
> ```
>
> 在app.js文件中最上方引入模块
>
> ```js
> const morgan = require('morgan');
> ```
>
> 浏览器刷新页面，控制 台没有输出， 因为是生产环境。
>
> 但是我们重新启动应用, 如下方式，重新刷新页面
>
> ```bash
> $ export NODE_ENV="development" ; nodemon app.js
> ```
>
> > 控制台将会输出
> >
> > ```bash
> > GET /favicon.ico 404 3.292 ms - 150
> > GET /admin/login 200 6.045 ms - 2402
> > 方法 路径 状态码 时间             - 大小
> > ```



### config模块区分不同环境配置

`config`模块，允许将配置信息抽取到文件中。`config`模块使用了，项目切换时，不需要在源码中修改，只需要修改环境变量就可以了。

在`app.js`文件的`if (process.env.NODE_ENV == "development") {` 紧挨着之上，粘贴以下代码

```js
console.log(config.get('title'))
```

> 安装
>
> ```bash
> npm install --save config
> ```
>
> 导入模块, 首行
>
> ```js
> const config =require('config');
> ```
>
> 准备根目录的config, 不能换名字
>
> ```bash
> install -dv config
> $ touch config/{default.json,development.json,production.json}
> ```
>
> 目录中准备3个配置
>
> - `default.json`        如果读取的配置信息，没有找到，就在default.json中查找。相当于会继承此文件
>
> - `development.json` 开发，config判断是开发，就读取此文件。
> - `production.json`生产
>
> 准备默认配置
>
> ```json
> {
> 	"title": "博客管理系统"
> }
> ```
>
> 准备开发环境
>
> ```json
> {
> 	"title": "博客管理系统 开发环境"
> }
> ```
>
> 准备生产环境
>
> ```json
> {
> 	"title": "博客管理系统 生产环境"
> }
> ```

在命令行中

```bash
$ export NODE_ENV="development" ; nodemon app.js
```

> 可以看到是开发环境

```bash
$ export NODE_ENV="" ; nodemon app.js
[nodemon] 2.0.12
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node app.js`
express-session deprecated undefined resave option; provide resave option app.js:21:9
博客管理系统 开发环境
生产环境

```

> config读不到变量是开发

```bash
$ export NODE_ENV="production" ; nodemon app.js
[nodemon] 2.0.12
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node app.js`
express-session deprecated undefined resave option; provide resave option app.js:21:9
Warning: connect.session() MemoryStore is not
designed for a production environment, as it will leak
memory, and will not scale past a single process.
博客管理系统 生产环境
生产环境
```

> 现在把生产环境中的配置清空，然后再执行
>
> `production.json`
>
> ```json
> {}
> ```
>
> > 注意，需要留着对象
>
> 现在再执行
>
> ```bash
> $ export NODE_ENV="production" ; nodemon app.js
> [nodemon] 2.0.12
> [nodemon] to restart at any time, enter `rs`
> [nodemon] watching path(s): *.*
> [nodemon] watching extensions: js,mjs,json
> [nodemon] starting `node app.js`
> express-session deprecated undefined resave option; provide resave option app.js:21:9
> Warning: connect.session() MemoryStore is not
> designed for a production environment, as it will leak
> memory, and will not scale past a single process.
> 博客管理系统
> 生产环境
> ```

现在恢复生产，并恢复默认环境走开发环境



### 开发环境配置数据库

编辑development.json

```json
{
	"db": {
		"user": "blog",
		"password": "blog",
		"host": "localhost",
		"port": "27017",
		"name": "blog"
	}
}
```

在connect.js中获取配置

```js
const mongoose=require('mongoose');
const config = require('config');

console.log(`获取数据库配置: ${process.env.NODE_ENV}, 数据库主机: ${config.get('db.host')}`)
mongoose.connect(`mongodb://${config.get('db.user')}:${config.get('db.password')}@${config.get('db.host')}:${config.get('db.port')}/${config.get('db.name')}`).then(() => console.log('mongo db connect success.')).catch( () => console.log('mongo db connect failed.'));
```

> - 导入模块
> - 模块字符获取变量值

现在两次启动

```bash
express-session deprecated undefined resave option; provide resave option app.js:21:9
获取数据库配置: development, 数据库主机: localhost
博客管理系统
开发
网站服务器启动成功，请访问 localhost:80
(node:11152) Warning: Accessing non-existent property 'count' of module exports inside circular dependency
(Use `node --trace-warnings ...` to show where the warning was created)
(node:11152) Warning: Accessing non-existent property 'findOne' of module exports inside circular dependency
(node:11152) Warning: Accessing non-existent property 'remove' of module exports inside circular dependency
(node:11152) Warning: Accessing non-existent property 'updateOne' of module exports inside circular dependency
(node:11152) DeprecationWarning: current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.
(node:11152) DeprecationWarning: collection.ensureIndex is deprecated. Use createIndexes instead.
mongo db connect success.

```

> - 数据库连接成功
> - 获取配置名，主机已经显示



项目给别人时，敏感信息别人可以看到，为了避免这个问题，config模块提供了解决方案。config将敏感信息提供在系统环境变量中，即使分享代码给别人，也不存在问题。

`config/custom-environment-variables.json`

敏感配置项的属性值

```json
{
	"db": {
		"password": "APP_PASSWORD"
	}
}
```

> 准备文件
>
> ```bash
> $ touch config/custom-environment-variables.json
> ```
>
> 在development.json文件中粘贴以下内容
>
> ```json
> {
> 	"db": {
> 		"user": "blog",
> 		"password": "APP_PASSWORD",
> 		"host": "localhost",
> 		"port": "27017",
> 		"name": "blog"
> 	}
> }
> ```
>
> > 密码的值就是`custom-environment-variables`的password的值。然后config就会读系统环境变量APP_PASSWORD替换到development.json中的password的值。

现在启动

```bash
$ export NODE_ENV="development"  APP_PASSWORD=""; nodemon app.js
[nodemon] 2.0.12
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node app.js`
express-session deprecated undefined resave option; provide resave option app.js:21:9
获取数据库配置: development, 数据库主机: localhost
博客管理系统
开发
网站服务器启动成功，请访问 localhost:80
mongo db connect failed.

```

> 连接失败

```bash
$  export NODE_ENV="development"  APP_PASSWORD="blog"; nodemon app.js
[nodemon] 2.0.12
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node app.js`
express-session deprecated undefined resave option; provide resave option app.js
:21:9
获取数据库配置: development, 数据库主机: localhost
博客管理系统
开发
网站服务器启动成功，请访问 localhost:80
mongo db connect success.

```

> 有正确的密码时，就连接成功了

现在已经实现了密码不在项目配置中，这样就保证了数据库是安全的

## 博客系统的前台展示页面

- 首页
- 文章详情页

### 依赖

1. 路由：客户端请求服务器时，响应模板
2. 抽离公共区域、骨架。修改外链资源地址

#### 路由

`route/home.js`

```js
// 引用express框架
const express = require('express');

// 创建博客展示页面路由, 返回路由对象
const home = express.Router();

home.get('/', require('./home/default'));

home.get('/article', require('./home/articlePage'));


// 将路由对象作为模块成员进行导出
module.exports = home;
```

> 相关相关的处理函数, 渲染模板文件
>
> ```bash
> install -dv route/home/
> ```
>
> 相关的`route/home/default.js`
>
> ```js
> module.exports = (req, res)=> {
> 	res.render('home/default.art')
> }
> ```
>
> `route/home/articlePage.js`
>
> ```js
> module.exports = (req, res)=> {
> 	res.render('home/article')
> }
> ```
>
> 准备静态文件
>
> `views/home/article.art`
>
> `views/home/default.art`



#### 更新模板引用资源为绝对路径

```bash
 find  views/home/ -type f -exec sed -i 's@src="\|href="@&/home/@g' {}  \;
```

绝对路径引用的资源，是起始于`blog/public`

#### 抽取公共部分和骨架

准备存放公共部分的目录

```bash
$ touch views/home/common/{layout.art,header.art,aside.art}
```

> 骨架
>
> 页面与页面间的公共部分

1. 骨架

   使用`bcompare`, 打开`python24/blog`, 比较`article.art`与`default.art`

   ![image-20210918095740282](http://myapp.img.mykernel.cn/image-20210918095740282.png)

   ![image-20210918095905418](http://myapp.img.mykernel.cn/image-20210918095905418.png)

   通过观察，head部分整体中只有2行不同，就取所有。

   而body整体部分，有大量不同，所以body就只取外部标签。。所以抽取如下

   `layout.art`

   ```html
     <!DOCTYPE html>
   <html lang="en">
   <head>
   	<meta charset="UTF-8">
   	<title>文章详情</title>
   	<link rel="stylesheet" href="/home/css/base.css">
   	<link rel="stylesheet" href="/home/css/article.css">
   </head>
   <body>
   </body>
   </html>
   ```

   现在在layout.art上把不同的区域替换成引入外部的

   ```html
     <!DOCTYPE html>
   <html lang="en">
   <head>
   	<meta charset="UTF-8">
   	{{ block 'title' }} {{ /block }}
   	<link rel="stylesheet" href="/home/css/base.css">
   	{{ block 'link' }} {{ /block }}
   </head>
   <body>
   	{{ block 'main' }} {{ /block }}
   </body>
   </html>
   
   ```

   现在把其他模板继承自这个layout骨架 `default.art`, 现在使用bcompare.exe完成 对比default.art与layout.art

   ![image-20210918100356875](http://myapp.img.mykernel.cn/image-20210918100356875.png)

   > 只需要将左侧继承自骨架，然后将其他红色部分，被右侧block包围

   ![image-20210918100535045](http://myapp.img.mykernel.cn/image-20210918100535045.png)

   > 依次完成左侧所有的红色部分被包围。然后删除左侧的白色部分。

   然后，article.art也参考以上完成。

   

现在验证访问

2. 抽取公共部分

   通过以上的对比，或者以下的default.art与article.art对比，可以发现header部分几乎一样，只是一行不一样，所以我们可以抽取为公共部分，include引入即可

   ![image-20210918101042465](http://myapp.img.mykernel.cn/image-20210918101042465.png)

   `views/home/common/header.art`

   ```html
   	<!-- 头部框架开始 -->
   	<div class="header">
   		<div class="w1100">
   			<!-- 网站logo开始 -->
   			<h1 class="logo fl">
   				<a href="/home/default"><img src="/home/images/logo.png" alt="黑马程序员"></a>
   			</h1>
   			<!-- 网站logo结束 -->
   			<!-- 网站导航开始 -->
   			<ul class="navigation fr">
   				<li>
   					<a class="active" href="/home/index.html">首页</a>
   				</li>
   				<li>
   					<a href="/home/#">登录</a>
   				</li>
   			</ul>
   			<!-- 网站导航结束 -->
   		</div>
   	</div>
   	<!-- 头部框架结束 -->
   ```

   现在把bcompare.exe中的这个部分替换为

   ```js
   {{ include './common/header.art' }}
   ```

   再次验证网页， 可以发现首页正常，但是文章页面也会反首页变亮

   ![image-20210918101643406](http://myapp.img.mykernel.cn/image-20210918101643406.png)

### 首页展示 

当用户访问首页时，就将文章数据查询出来，路由请求函数中，渲染出首页

1. 首页路由 `route/home/default.js`

   ```js
   let { Article } = require('../../model/article');
   
   module.exports = async (req, res)=> {
   	let artciles = await Article.find({}) 
   	res.send(artciles)
   	return; 
   	
   	res.render('home/default', {
   		artciles
   	})
   }
   ```

   > 文章是对象，所以解构 对象
   >
   > 查询是异步方法，所以在函数中使用async, await. 变成异步函数
   >
   > 先测试是否查询成功, 
   >
   > ![image-20210918102721167](http://myapp.img.mykernel.cn/image-20210918102721167.png)
   >
   > > author字段存储的是用户的id属性，但是在页面中是展示用户名

多表联合查询

```diff
let { Article } = require('../../model/article');

module.exports = async (req, res)=> {
+	let artciles = await Article.find({}).populate('author')
	res.send(artciles)
	return; 

	res.render('home/default', {
		artciles
	})
}
```

浏览器刷新, 就可以看到author转换为对象了

![image-20210918103046071](http://myapp.img.mykernel.cn/image-20210918103046071.png)

 现在注释这个代码，并进行渲染

	res.send(artciles)
	return; 

![image-20210918103240928](http://myapp.img.mykernel.cn/image-20210918103240928.png)

由于用户要分页，所以引入分页的模块

```js
let { Article } = require('../../model/article');
const pagination = require('mongoose-sex-page');

module.exports = async (req, res)=> {
	let page = req.query.page || 1;

	let articles = await pagination(Article).find({}).page(page).size(6).display(4).populate('author').exec()
	res.send(artciles)
	return;
    
	res.render('home/default', {
		articles
	})
}
```

> pagination是模块的方法，可以提供表给它，支持的方法。
>
> page 当前页
>
> size 每页数，图是6个
>
> display 当前客户端显示的页数列表， 图是4个
>
> exec 执行语句 

现在浏览器访问时, 将输出以下框架

```json
{
"page": 1,
"size": 6,
"total": 30,
"records": [],
"pages": 5,
"display": [
1,
2,
3,
4
]
}
```

由于30个，每页6个，应该有5页，但是我们定义是4个，所以下面客户端显示只能选择4页

现在就需要展示页面了，先去掉`	res.send(artciles)      \n return;` 代码

编辑模板`views/home/default.js`

通过观察每一个展示的li标签的类不一样

![image-20210918105312320](http://myapp.img.mykernel.cn/image-20210918105312320.png)

所以循环时，索引奇数为`fl`, 偶数`fr`类名

```diff
	<ul class="list w1100">
+	{{ each articles.records }}
+			<li class="{{ $index%2 == 0 ? 'fl' : 'fr' }}"> +
+			<a href="/home/article" class="thumbnail">
+				<img src="{{ $value.cover }}">
+			</a>
+			<div class="content">
+				<a class="article-title" href="/home/article.html">{{ $value.title }}</a>
+				<div class="article-info">
+					<span class="author">{{  $value.author.username }}</span>
+					<span>{{ dateFormat($value.publishDate, 'yyyy-mm-dd') }}</span>
+				</div>
+				<div class="brief">
+					{{@ $value.content.replace(/\<[^\<\>]+\>/g,'').substr(0,150) + '...'}}
+				</div>
+			</div>
+		</li>
+	{{ /each }}
	</ul>
	
	
	<!-- 分页开始 -->
	<div class="page w1100">
+		{{ if articles.page > 1}}
+		<a href="/home?page={{ articles.page-1}}">上一页</a>
+		{{/if}}

+		<% for (let i=0; i<=articles.display.length; i++) {%>
+		<a href="/home?page={{articles.display[i]}}" class="{{ articles.display[i]== articles.page ? 'active' : '' }}">{{articles.display[i]}}</a>
+		<% } %>
+		{{ if articles.page < articles.pages}}
+		<a href="/home?page={{ articles.page-0+1}}">下一页</a>
+		{{/if}}
	</div>
	<!-- 分页结束 -->
```

> 由于$index是返回索引从0起始，所以第1个为`fr`, 就是偶数为fr
>
> 内容要去掉内容中的`<p></p>`标签.
>
> 由于当前内容可能非常高，可能会撑大<div, 所以就使用substr()来截取字符，之后添加 `...` 表示很多字符
>
> &nbsp是空格，需要原文输出, 所以添加@`{{@ $value.content.replace(/\<[^\<\>]+\>/g,'').substr(0,150) + '...'}}`
>
> - 遍历页码可以换一个方式, 即遍历数组的值
>
>   ```js
>   		{{ each articles.display }}
>   		<a href="/home?page={{$value}}" class="{{ $value== articles.page ? 'active' : '' }}">{{$value}}</a>
>   		{{ /each }}
>   ```

![image-20210918105808863](http://myapp.img.mykernel.cn/image-20210918105808863.png)



### 文章页展示

点击列表的图片，进入详情页面

1. 用户点了，之后，把文章id给文章路由

```diff
				<div class="content">
+					<a class="article-title" href="/home/article?id={{@ $value._id}}">{{ $value.title }}</a>
```

2. 准备路由

   `route/home/articlePage.js`

   ```js
   let { Article} = require('../../model/article')
   
   module.exports = async (req, res)=> {
   	let { id } = req.query;
   
   	let article = await Article.findOne({_id: id}).populate('author')
   	res.send(article)
   	return; 
   	
   	res.render('home/article', {
   		article
   	})
   }
   ```

   结果

   ```json
   {
   "cover": "/uploads/upload_2267cd5c58a35b816d9ff7ea94eaf708.jpg",
   "_id": "61454f1ef7a4243b38c51911",
   "title": "hello 15",
   "author": {
   "state": 0,
   "_id": "61444054bc116d40608e5115",
   "username": "zhuwu",
   "email": "zhuwu@itcast.cn",
   "password": "$2b$10$l9HZZeXFndeBJWdnDwiW/eSoeintucVx59vRgWZNWslb3Mlv.DLx2",
   "role": "normal",
   "__v": 0
   },
   "publishDate": "2021-09-26T00:00:00.000Z",
   "content": "<p>15</p>",
   "__v": 0
   }
   ```

   现在，就可以注释以下代码，真正渲染到模板了

   	res.send(article)
   	return; 

3. 配置模板 `views/home/article.art`

   ```diff
   			<div class="container">
   				<div class="article-header">
   +					<h3 class="article-title">{{ article.title }}</h3>
   					<div class="article-info">
   +						<span class="author">{{ article.author.username }}</span>
   +						<span>{{ dateFormat(article.publishDate, 'yyyy-mm-dd') }}</span>
   					</div>
   				</div>
   				<div class="article-content">
   +					{{@ article.content }}
   				</div>
   				<div class="article-comment">
   					<h4>评论</h4>
   					
   					<form class="comment-form">
   ```

   > `{{@ article.content }}`其中的@符号，会屏蔽html标签和其他非原文字符，比如上面的空格。

## 文章评论

### 实现步骤

评论不是在用户集合中，而是在评论集群中

1. 创建评论集合
2. 评论文章，需要用户是登陆状态。用户是登陆的，才可以提交评论
3. 服务器端创建评论的路由，函数中获取评论信息
4. 评论后，页面重定向到详情页，然后在详情页中查询当前文章的评论信息，并展示在页面中。

### 评论集合

`model/comment.js`

评论集合中，字段？

- 评论的是一篇文章

- 评论人信息，邮箱

  ![image-20210918113411367](http://myapp.img.mykernel.cn/image-20210918113411367.png)

- 发布时间

```js
// 引入mongoose模块
const mongoose = require('mongoose');

// 创建评论集合规则
const commentSchema = new mongoose.Schema({
	// 文章id
	aid: {
		type: mongoose.Schema.Types.ObjectId,
		ref: 'Article', // mongoose.model('Article', ArticleSchema); 其中的字符
	},
	// 用户id
	uid: {
		type: mongoose.Schema.Types.ObjectId,
		ref: 'User', //mongoose.model('User', UserSchema);
	},
	// 发布时间
	time: {
		type: Date,
		default: Date.now
	},
	content: {
		type: String,
		required: true
	}
});


// 创建评论集合
const Comment = mongoose.model('Comment', commentSchema)

// 导出
module.exports = {
	Comment
}
```

### 登陆时，不同用户到不同的页面

评论时，需要用户登陆。所以需要登陆后，判断用户角色，超级管理员，就跳转到后台管理系统。如果登陆用户是普通用户，就跳转到博客首页

`route/admin/login.js`

```diff
	if (user) {
		// true成功
		// false 失败
		let isVaild = await bcrypt.compare(password, user.password)
		if ( isVaild ) {
			req.session.username = user.username; // 将用户名存储到session对象中
			// 登录成功
			req.app.locals.userInfo = user;

+			if (user.role == "admin") {
+				res.redirect('/admin/user')
+			} else {
+				res.redirect('/home');
+			}
		} else {
```

> 登陆管理员时，就是管理页面。`zhuwu@itcast.cn`
>
> 普通用户就是在首页 `lizhong@itcast.cn`

### 登陆后，仅管理员可以到达后台页面。即/admin起始的页面

现在有一个问题，当普通用户登陆后，访问`/admin/user`同样 可以进入后台。登陆拦截只能拦截用户是否登陆，才可以访问/admin/前缀的用户。

所以我们需要修改登陆拦截的代码`app.js`

```js
// 拦截请求，判断用户登录状态
app.use('/admin', require('./middleware/loginGuard'));
```

> 修改关联的文件; 用户未登陆访问/admin前缀，就跳转登陆，否则时，管理员才可以放行
>
> ```diff
> 
> const guard = (req, res, next) => {
> 	// 判断用户访问的是否登录页面
> 	//判断用户登录状态，是登录的就放行。不登录就重定向
> 	if (req.url != '/login' && ! req.session.username ) { // 非登陆页，未登陆
> 		res.redirect('/admin/login');
> 	} else {
> 		// 是登陆状态， 放行请求
> 		
> +		// 如果登陆状态，并且是普通用户，就跳转首页，就阻止向下执行。
> +		if (req.session.role == 'normal') {
> +			res.redirect('/home')
> +			return
> +		} 
> 		next();
> 	}
> };
> 
> 
> ```
>
> > - session中存储role, `route/admin/login.js`
> >
> >   ```diff
> >   		let isVaild = await bcrypt.compare(password, user.password)
> >   		if ( isVaild ) {
> >   			req.session.username = user.username; // 将用户名存储到session对象中
> >   +			req.session.role = user.role; //session中存储用户角色
> >   ```

现在普通用户登陆后，手工访问`/admin/user`，还是会跳转到首页



### 评论展示

- 当用户登陆了，就展示评论。

- 当用户没有登陆，就不展示评论表单，并提示如果要评论文章就先登陆，仅展示评论列表

接下来，文章详情页面，如何判断用户是否登陆？

用户登陆后，会把用户信息存储 在`req.app.locals.userInfo`中, 此对象可以**在模板中直接访问**

所以模板中，判断userInfo存在，就登陆了。没有就没有登陆。

`views/home/article.art`

```diff
	<div class="article">
		<div class="w1100">
			<div class="container">
				<div class="article-header">
					<h3 class="article-title">{{ article.title }}</h3>
					<div class="article-info">
						<span class="author">{{ article.author.username }}</span>
						<span>{{ dateFormat(article.publishDate, 'yyyy-mm-dd') }}</span>
					</div>
				</div>
				<div class="article-content">
					{{@ article.content }}
				</div>
				<div class="article-comment">
+					{{if userInfo}}
+					<h4>评论</h4>
+					
+					<form class="comment-form">
+						<textarea class="comment"></textarea>
+						<div class="items">
+							<input type="submit" value="提交">
+						</div>
+					</form>
+					{{else}}
+					<div><h2>先登陆，再评论</h2></div>
+					{{ /if}}
					<div class="comment-list">
```

现在浏览器刷新访问详情页

![image-20210918120019287](http://myapp.img.mykernel.cn/image-20210918120019287.png)

登陆后，查看评论表单， 是可以查看的

现在有一个bug, 用户就算登出后，还是可以显示这个post, 因为用户`userInfo`存放在req.app.locals中，在登出时没有清理此对象 `logout.js`

```diff
module.exports = (req, res) => {
	//删除session
	req.session.destroy(function () {
		// 删除cookie
		res.clearCookie('connect.sid');
		// 重定向到用户登录页
		res.redirect('/admin/login');
+        req.app.locals.userInfo = null;
	})
}
```

现在就OK了



### 提交评论

路由

name属性，隐藏域：文章id、用户id

`article.art`

```diff
				<div class="article-comment">
					{{if userInfo}}
					<h4>评论</h4>
					
+					<form class="comment-form" method="POST" action="/home/comment">
+						<textarea class="comment" name="content"></textarea>
+						<input type="hidden" name="uid" value="{{ userInfo._id }}">
+						<input type="hidden" name="aid" value="{{ article._id }}">
						<div class="items">
							<input type="submit" value="提交">
						</div>
					</form>
```



先登陆，用户评论，点提交

创建路由 home.js

```js
home.post('/comment', require('./home/comment.js'))
```

> ```js
> module.exports = (req, res) => {
> 	res.send('ok')
> }
> ```

先登陆，用户评论，点提交

![image-20210918123438038](http://myapp.img.mykernel.cn/image-20210918123438038.png)

接收用户传递的评论信息

现在输出地址

![image-20210918123539907](http://myapp.img.mykernel.cn/image-20210918123539907.png)

现在就可以将评论保存到数据了

```js
let { Comment } = require('../../model/comment')

module.exports = async (req, res) => {
	let {aid, uid, content} = req.body


	await Comment.create({
		aid: aid,
		uid: uid,
		content: content,
		time: new Date()
	})

	res.redirect(`/home/article?id=${aid}`)
}
```

![image-20210918124439320](http://myapp.img.mykernel.cn/image-20210918124439320.png)

### 评论显示

在文章详情页面中，展示

1. 文章详情页面的路由中，传递查询的评论 `route/home/articlePage.js`

   ```diff
   let { Article} = require('../../model/article')
   +let { Comment } = require('../../model/comment')
   
   module.exports = async (req, res)=> {
   	let { id } = req.query;
   
   	let article = await Article.findOne({_id: id}).populate('author')
   
   +	let comments = await Comment.find({aid: article._id})
   
   	res.send(comments) // 测试代码
   	return; // 测试代码
   	
   	res.render('home/article', {
   		article,
   +		comments
   	})
   }
   ```

   浏览器请求具体文章

   ```json
   [
   {
   "_id": "61456e6112c25c0f60823d37",
   "aid": "61454f1ef7a4243b38c51903",
   "uid": "61444054bc116d40608e5115",
   "content": "123",
   "time": "2021-09-18T04:43:13.821Z",
   "__v": 0
   }
   ]
   ```

   需要显示具体人的信息, 添加关联查询

   ```js
   	let comments = await Comment.find({aid: article._id}).populate('uid')
   ```

   浏览器请求的结果

   ```json
   [
   {
   "_id": "61456e6112c25c0f60823d37",
   "aid": "61454f1ef7a4243b38c51903",
   "uid": {
   "state": 0,
   "_id": "61444054bc116d40608e5115",
   "username": "zhuwu",
   "email": "zhuwu@itcast.cn",
   "password": "$2b$10$l9HZZeXFndeBJWdnDwiW/eSoeintucVx59vRgWZNWslb3Mlv.DLx2",
   "role": "admin",
   "__v": 0
   },
   "content": "123",
   "time": "2021-09-18T04:43:13.821Z",
   "__v": 0
   }
   ]
   ```

   现在模板中，渲染评论

   ```diff
   					{{else}}
   					<div><h2>先登陆，再评论</h2></div>
   					{{ /if}}
   					<div class="comment-list">
   +						{{ each comments }}
   						<div class="mb10">
   							<div class="article-info">
   +								<span class="author">{{ $value.uid.username }}</span>
   +								<span>{{ dateFormat($value.time, 'yyyy-mm-dd') }}</span>
   +								<span>{{ $value.uid.email }}</span>
   							</div>
   							<div class="comment-content">
   +								{{ $value.content }}
   							</div>
   						</div>
   +						{{/each}}
   					</div>
   				</div>
   			</div>
   		</div>
   	</div>
   ```

   现在页面刷新

   去掉上面的测试代码

   ![image-20210918125326247](http://myapp.img.mykernel.cn/image-20210918125326247.png)

现在换一个用户，评论查看结果

![image-20210918125414418](http://myapp.img.mykernel.cn/image-20210918125414418.png)

### 首页的登陆

由于是header, 就编辑`views/home/common/header.art`

```diff
	<!-- 头部框架开始 -->
	<div class="header">
		<div class="w1100">
			<!-- 网站logo开始 -->
			<h1 class="logo fl">
				<a href="/home/default"><img src="/home/images/logo.png" alt="黑马程序员"></a>
			</h1>
			<!-- 网站logo结束 -->
			<!-- 网站导航开始 -->
			<ul class="navigation fr">
				<li>
					<a class="active" href="/home/index.html">首页</a>
				</li>
+				{{if ! userInfo}}
				<li>
					<a href="/admin/login">登录</a>
				</li>
+				{{else}}
+				<li>
+					<a href="/admin/logout?id={{userInfo._id}}">{{userInfo.username}} 退出登录</a>
+				</li>
+				{{/if}}
			</ul>
			<!-- 网站导航结束 -->
		</div>
	</div>
	<!-- 头部框架结束 -->
```



