---
title: "用proc解决问题"
date: 2020-11-25 01:48:02
tags: 日常挖掘
---

原文: https://blogs.oracle.com/linux/solving-problems-with-proc-v2



几乎所有linux系统，都会有proc文件系统挂载在/proc目录。

```bash
# mount | grep ^proc
proc    on /proc type proc     (rw,nosuid,nodev,noexec,relatime)
源         目录    文件系统类型    挂载选项
```

看看/proc目录，你将看到很多东西

![image-20201125101608389](http://myapp.img.mykernel.cn/image-20201125101608389.png)

这些目录和文件在磁盘上不存在，而是当你读这个目录时，kernel生成了内容。

proc是unix的一切皆文件哲学思想的一个最好的例子，它将自己的内部状态输出为一组文件。因此你可以通过`shell script`或其他编程语言来构建自己的工具。或者通过写入/proc目录的某些文件来改变内核的行为。

1. 每个进程在/proc目录中有一个自己进程标识符(pid)命名的目录.

   ```bash
   #示例：top命令(pid获取到为5001)的相关信息存储在/proc/5001/目录中。
   # top # 终端1
   # ls /proc/$(pgrep top)/ # 终端2
   ```

   ![image-20201125102739046](http://myapp.img.mykernel.cn/image-20201125102739046.png)

2. /proc/self ：自动链接到当前进程的pid目录。每个进程去读取这个文件，都可以访问到关于此进程的相关信息。

   ```bash
   #示例: ls执行时的pid号
   # ls -l /proc/self
   lrwxrwxrwx 1 root root 0 11月 20 23:02 /proc/self -> 1289
   
   # 此时ls进程已经终止, 这个目录已经自动删除了。
   # ls /proc/1289
   ls: 无法访问/proc/1289: 没有那个文件或目录
   
   ```

   


# 1. io-bound or cpu bound?

当我们执行以下命令时, 可以看到输出

```bash
# pgrep top
5001
# cat /proc/5001/status | grep ctxt_switches 
voluntary_ctxt_switches:        142         #  
nonvoluntary_ctxt_switches:     13538
```

voluntary_ctxt_switches：voluntary context switch, 表示自愿的上下文切换，即程序发起system call时，需要等待一些资源或事件。就自愿的进行进程上下文切换，进入睡眠态。 所以在IO密集的进程，这个切换较多，值较高。

nonvoluntary_ctxt_switches： *nonvoluntary* context switch, 表示非自愿的上下文切换，如果进程只做纯计算，而且一直没有计算完，就会一直消耗CPU，内核在该进程使用完一个硬件时针周期后，就发起中断让进程进行非自愿的上下文切换。         所以在CPU密集的进程，这个切换较多，值较高。



<!--more-->

# 2. Back from the dead

如果一个文件有很大，在你使用过程中，不小心删除了这个文件，恢复如下

```bash
#假如，这个文件25G

# file
-rw-r--r-- 1 root root 25G 11月 10 17:42  file


# 一个进程正在使用他, 通过这个进程的fd可以看到
[root@wzx ~]# ls -l /proc/$(pgrep '\<mysql\>')/fd
总用量 0
lr-x------ 1 root root 64 11月 25 10:40 0 -> file
lrwx------ 1 root root 64 11月 25 10:40 1 -> /dev/pts/2
lrwx------ 1 root root 64 11月 25 10:40 2 -> /dev/pts/2
lrwx------ 1 root root 64 11月 25 10:40 3 -> socket:[246870932]


# 这时，你删除了这个文件
rm -f file


# 在查看这个进程的fd
[root@wzx ~]# ls -l /proc/$(pgrep '\<mysql\>')/fd
总用量 0
lr-x------ 1 root root 64 11月 25 10:40 0 -> file (deleted)


# 恢复这个文件
cp -a /proc/$(pgrep '\<mysql\>')/fd/0 file-a
```



有一个很大的警告：对文件进行逐字节完整复制可能需要大量时间和可用磁盘空间。

从理论上讲，这不是必需的。该文件仍存在于磁盘上，我们只需要为其命名一个新名称（硬链接）。

但是ln命令和关联的系统调用无法命名已删除的文件。在FreeBSD上，我们可以使用[fsdb](http://nixdoc.net/man-pages/FreeBSD/man8/fsdb.8.html)，但是我不知道用于Linux的类似工具。



# 3. 幽灵进度条

如果你正在处理一个文件，不知道文件处理到什么进度, 可以使用如下命令查看

## 3.1 获取进程的pid

```bash
# pgrep '\<mysql\>'
13429
```

## 3.2 获取进程打开文件的描述符号码

```bash
[root@wzx ~]# ls -l /proc/13429/fd/
总用量 0
lr-x------ 1 root root 64 11月 25 10:40 0 -> /weizhixiu/mysql-backup/backup/full_backup/backup/full_backup/prod_full_backup-2020-11-10_16-05-54-.sql
lrwx------ 1 root root 64 11月 25 10:40 1 -> /dev/pts/2
lrwx------ 1 root root 64 11月 25 10:40 2 -> /dev/pts/2
lrwx------ 1 root root 64 11月 25 10:40 3 -> socket:[246870932]
```

## 3.3 获取进度

```bash
#安装dialog
# yum -y install dialog

#生成脚本
cat > phantom-progress.sh <<EOF
#!/bin/bash
fd=/proc/$1/fd/$2
fdinfo=/proc/$1/fdinfo/$2
name=$(readlink $fd)
size=$(wc -c $fd | awk '{print $1}')
while [ -e $fd ]; do
  progress=$(cat $fdinfo | grep ^pos | awk '{print $2}')
  echo $((100*$progress / $size))
  sleep 1
done | dialog --gauge "Progress reading $name" 7 100
EOF

#执行脚本
# bash phantom-progress.sh 13429 0
```

![image-20201125111726989](http://myapp.img.mykernel.cn/image-20201125111726989.png)





# 4. 追踪插件

用户遇到了一个问题：每隔一段时间，他们的Enterprise FooServer实例就会崩溃。加载错误的库很可能导致神秘的崩溃。

加载的库的确切集合将取决于用户的配置文件以及[LD_PRELOAD和LD_LIBRARY_PATH之](http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html)类的环境变量。

```bash
#获取此进程的pid
# pgrep 'fooserver\>'
21637

#获取此进程的加载的库
# cat /proc/21637/maps
00400000-00401000 r-xp 00000000 fe:02 475918             /usr/bin/fooserver
00600000-00601000 rw-p 00000000 fe:02 475918             /usr/bin/fooserver
02519000-0253a000 rw-p 00000000 00:00 0                  [heap]
7ffa5d3c5000-7ffa5d3c6000 r-xp 00000000 fe:02 1286241    /usr/lib/foo-1.2/libplugin-bar.so
7ffa5d3c6000-7ffa5d5c5000 ---p 00001000 fe:02 1286241    /usr/lib/foo-1.2/libplugin-bar.so
7ffa5d5c5000-7ffa5d5c6000 rw-p 00000000 fe:02 1286241    /usr/lib/foo-1.2/libplugin-bar.so
7ffa5d5c6000-7ffa5d5c7000 r-xp 00000000 fe:02 1286243    /usr/lib/foo-1.3/libplugin-quux.so
7ffa5d5c7000-7ffa5d7c6000 ---p 00001000 fe:02 1286243    /usr/lib/foo-1.3/libplugin-quux.so
7ffa5d7c6000-7ffa5d7c7000 rw-p 00000000 fe:02 1286243    /usr/lib/foo-1.3/libplugin-quux.so
7ffa5d7c7000-7ffa5d91f000 r-xp 00000000 fe:02 4055115    /lib/libc-2.11.2.so
7ffa5d91f000-7ffa5db1e000 ---p 00158000 fe:02 4055115    /lib/libc-2.11.2.so
7ffa5db1e000-7ffa5db22000 r--p 00157000 fe:02 4055115    /lib/libc-2.11.2.so
7ffa5db22000-7ffa5db23000 rw-p 0015b000 fe:02 4055115    /lib/libc-2.11.2.so
7ffa5db23000-7ffa5db28000 rw-p 00000000 00:00 0 
7ffa5db28000-7ffa5db2a000 r-xp 00000000 fe:02 4055114    /lib/libdl-2.11.2.so
7ffa5db2a000-7ffa5dd2a000 ---p 00002000 fe:02 4055114    /lib/libdl-2.11.2.so
7ffa5dd2a000-7ffa5dd2b000 r--p 00002000 fe:02 4055114    /lib/libdl-2.11.2.so
7ffa5dd2b000-7ffa5dd2c000 rw-p 00003000 fe:02 4055114    /lib/libdl-2.11.2.so
7ffa5dd2c000-7ffa5dd4a000 r-xp 00000000 fe:02 4055128    /lib/ld-2.11.2.so
7ffa5df26000-7ffa5df29000 rw-p 00000000 00:00 0 
7ffa5df46000-7ffa5df49000 rw-p 00000000 00:00 0 
7ffa5df49000-7ffa5df4a000 r--p 0001d000 fe:02 4055128    /lib/ld-2.11.2.so
7ffa5df4a000-7ffa5df4b000 rw-p 0001e000 fe:02 4055128    /lib/ld-2.11.2.so
7ffa5df4b000-7ffa5df4c000 rw-p 00000000 00:00 0 
7fffedc07000-7fffedc1c000 rw-p 00000000 00:00 0          [stack]
7fffedcdd000-7fffedcde000 r-xp 00000000 00:00 0          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0  [vsyscall]
```

fooserver从FooServer 1.2版加载bar插件，从FooServer 1.3版加载quux插件。如果版本不是二进制兼容的，那可能可以解释神秘的崩溃。









